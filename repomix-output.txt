This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-13T02:31:53.558Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
prisma/
  migrations/
    20250312123324_init/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  app/
    api/
      auth/
        login/
          route.js
        logout/
          route.js
        register/
          route.js
      comments/
        route.js
      groups/
        [id]/
          join/
            route.js
          leave/
            route.js
        check/
          route.js
        route.js
      posts/
        friends/
          route.js
        popular/
          route.js
        recent/
          route.js
        search/
          route.js
        route.js
      users/
        [username]/
          friend/
            route.js
          route.js
        search/
          route.js
      votes/
        score/
          route.js
        status/
          route.js
        route.js
    auth/
      login/
        page.js
      register/
        page.js
    create/
      group/
        page.js
      post/
        page.js
    explore/
      page.js
    friends/
      page.js
    group/
      [group]/
        comments/
          [postId]/
            page.js
        page.js
    popular/
      page.js
    search/
      page.js
    user/
      [username]/
        client.js
        page.js
    globals.css
    layout.js
    page.js
  components/
    auth/
      AuthContext.js
    comment/
      CommentForm.js
      CommentItem.js
      CommentSection.js
    group/
      GroupAbout.js
      GroupHeader.js
      GroupSidebar.js
    layout/
      Header.js
      LeftSidebar.js
    post/
      FriendsPosts.js
      PopularPosts.js
      PostItem.js
      PostList.js
      RecentPosts.js
    ui/
      Button.js
  lib/
    auth.js
    db.js
    utils.js
.gitignore
docker-compose.yml
Dockerfile
jsconfig.json
next-env.d.ts
next.config.js
package.json
postcss.config.mjs
README.md
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: prisma/migrations/20250312123324_init/migration.sql
================
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "username" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "Friendship" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "friendId" TEXT NOT NULL,
    CONSTRAINT "Friendship_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "Friendship_friendId_fkey" FOREIGN KEY ("friendId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Group" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    "ownerId" TEXT NOT NULL,
    CONSTRAINT "Group_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "GroupsOnUsers" (
    "groupId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "joinedAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY ("groupId", "userId"),
    CONSTRAINT "GroupsOnUsers_groupId_fkey" FOREIGN KEY ("groupId") REFERENCES "Group" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "GroupsOnUsers_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Post" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "content" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    "authorId" TEXT NOT NULL,
    "groupId" TEXT NOT NULL,
    CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "Post_groupId_fkey" FOREIGN KEY ("groupId") REFERENCES "Group" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "content" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    "authorId" TEXT NOT NULL,
    "postId" TEXT NOT NULL,
    "parentId" TEXT,
    CONSTRAINT "Comment_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "Comment_postId_fkey" FOREIGN KEY ("postId") REFERENCES "Post" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "Comment_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "Comment" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Vote" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "value" INTEGER NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    "userId" TEXT NOT NULL,
    "postId" TEXT,
    "commentId" TEXT,
    CONSTRAINT "Vote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "Vote_postId_fkey" FOREIGN KEY ("postId") REFERENCES "Post" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "Vote_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Friendship_userId_friendId_key" ON "Friendship"("userId", "friendId");

-- CreateIndex
CREATE UNIQUE INDEX "Group_name_key" ON "Group"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Vote_userId_postId_key" ON "Vote"("userId", "postId");

-- CreateIndex
CREATE UNIQUE INDEX "Vote_userId_commentId_key" ON "Vote"("userId", "commentId");

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  posts       Post[]
  comments    Comment[]
  votes       Vote[]
  groups      GroupsOnUsers[]
  ownedGroups Group[]         @relation("GroupOwner")

  // Friendship relations
  friendsAdded Friendship[] @relation("UserFriends")
  friendsOf    Friendship[] @relation("FriendOf")
}

model Friendship {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Define the relationship between users
  userId   String
  friendId String

  // Relations with User model
  user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)

  // Make sure each friendship only exists once
  @@unique([userId, friendId])
}

model Group {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Owner relation
  ownerId String
  owner   User   @relation("GroupOwner", fields: [ownerId], references: [id])

  // Relations
  posts   Post[]
  members GroupsOnUsers[]
}

model GroupsOnUsers {
  groupId  String
  userId   String
  joinedAt DateTime @default(now())

  // Relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Composite primary key
  @@id([groupId, userId])
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  groupId String
  group   Group  @relation(fields: [groupId], references: [id])

  comments Comment[]
  votes    Vote[]
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Author relation
  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  // Post relation
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Parent comment (for nested comments)
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies  Comment[] @relation("CommentReplies")

  // Relations
  votes Vote[]
}

model Vote {
  id        String   @id @default(cuid())
  value     Int // 1 for upvote, -1 for downvote
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User relation
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Post or Comment relation (one or the other, not both)
  postId    String?
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Ensure a user can only vote once on a post/comment
  @@unique([userId, postId])
  @@unique([userId, commentId])
}

================
File: src/app/api/auth/login/route.js
================
import { NextResponse } from "next/server";
import { verifyCredentials } from "@/lib/auth";
import { z } from "zod";
import { cookies } from "next/headers";
import { sign } from "jsonwebtoken";

// Define validation schema
const loginSchema = z.object({
  usernameOrEmail: z.string().min(3),
  password: z.string().min(1),
});

export async function POST(request) {
  try {
    const body = await request.json();

    // Validate request data
    const result = loginSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { usernameOrEmail, password } = body;

    // Verify credentials
    const credResult = await verifyCredentials(usernameOrEmail, password);

    if (!credResult.success) {
      // Use a generic error message for both user not found and invalid password
      // This is a security best practice to prevent username enumeration
      if (
        credResult.error === "auth/user-not-found" ||
        credResult.error === "auth/invalid-password"
      ) {
        return NextResponse.json(
          { error: "Invalid username/email or password" },
          { status: 401 }
        );
      }

      // Handle other potential errors
      return NextResponse.json(
        { error: "Authentication failed" },
        { status: 401 }
      );
    }

    // User authenticated successfully
    const user = credResult.user;

    // Within your POST function:
    // Create JWT token
    const token = sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET || "reddit-clone-secret-key",
      { expiresIn: "7d" }
    );

    // Create response
    const response = NextResponse.json(
      {
        message: "Login successful",
        user: { id: user.id, username: user.username },
      },
      { status: 200 }
    );

    // Set cookie on the response
    response.cookies.set({
      name: "auth-token",
      value: token,
      httpOnly: true,
      path: "/",
      secure: process.env.NODE_ENV === "production",
      maxAge: 60 * 60 * 24 * 7, // 7 days
      sameSite: "strict",
    });

    return response;
  } catch (error) {
    console.error("Login error:", error);

    if (
      error.message === "User not found" ||
      error.message === "Invalid password"
    ) {
      return NextResponse.json(
        { error: "Invalid credentials" },
        { status: 401 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/auth/logout/route.js
================
import { NextResponse } from "next/server";
import { cookies } from "next/headers";

export async function POST() {
  try {
    // Get the cookie store
    const cookieStore = cookies();

    // Create a response
    const response = NextResponse.json(
      { message: "Logged out successfully" },
      { status: 200 }
    );

    // Delete the cookie by setting it with an expired date
    response.cookies.set({
      name: "auth-token",
      value: "",
      httpOnly: true,
      path: "/",
      expires: new Date(0), // Set to epoch time to expire immediately
    });

    return response;
  } catch (error) {
    console.error("Logout error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/auth/register/route.js
================
import { NextResponse } from "next/server";
import { createUser } from "@/lib/auth";
import { z } from "zod";

// Define validation schema
const registerSchema = z.object({
  username: z.string().min(3).max(50),
  email: z.string().email(),
  password: z.string().min(8),
});

export async function POST(request) {
  try {
    const body = await request.json();

    // Validate request data
    const result = registerSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { username, email, password } = body;

    // Create user
    const user = await createUser({ username, email, password });

    return NextResponse.json(
      { message: "User registered successfully", user },
      { status: 201 }
    );
  } catch (error) {
    console.error("Registration error:", error);

    if (
      error.message === "Username already exists" ||
      error.message === "Email already exists"
    ) {
      return NextResponse.json({ error: error.message }, { status: 409 });
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/comments/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";
import { z } from "zod";

// Define validation schema
const commentSchema = z.object({
  content: z.string().min(1),
  postId: z.string().min(1),
  parentId: z.string().optional(),
});

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const postId = searchParams.get("postId");

  if (!postId) {
    return NextResponse.json({ error: "Post ID is required" }, { status: 400 });
  }

  try {
    // Get all comments for the post
    const comments = await prisma.comment.findMany({
      where: {
        postId,
      },
      include: {
        author: {
          select: {
            username: true,
          },
        },
        _count: {
          select: {
            votes: true,
            replies: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Organize comments into a nested structure
    const commentMap = {};
    const rootComments = [];

    // First pass: Create a map of all comments
    comments.forEach((comment) => {
      comment.replies = [];
      commentMap[comment.id] = comment;
    });

    // Second pass: Build the comment tree
    comments.forEach((comment) => {
      if (comment.parentId) {
        // This is a reply, add it to its parent's replies
        if (commentMap[comment.parentId]) {
          commentMap[comment.parentId].replies.push(comment);
        }
      } else {
        // This is a root comment
        rootComments.push(comment);
      }
    });

    return NextResponse.json({ comments: rootComments });
  } catch (error) {
    console.error("Error fetching comments:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();

    // Validate request data
    const result = commentSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { content, postId, parentId } = body;

    // Check if post exists
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }

    // If parentId is provided, check if parent comment exists
    if (parentId) {
      const parentComment = await prisma.comment.findUnique({
        where: { id: parentId },
      });

      if (!parentComment) {
        return NextResponse.json(
          { error: "Parent comment not found" },
          { status: 404 }
        );
      }
    }

    // Create comment
    const comment = await prisma.comment.create({
      data: {
        content,
        authorId: user.userId,
        postId,
        parentId,
      },
      include: {
        author: {
          select: {
            username: true,
          },
        },
      },
    });

    return NextResponse.json(
      { message: "Comment created successfully", comment },
      { status: 201 }
    );
  } catch (error) {
    console.error("Error creating comment:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/groups/[id]/join/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function POST(request, { params }) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Await params before accessing its properties
    const resolvedParams = await params;
    const { id } = resolvedParams;

    // Check if group exists
    const group = await prisma.group.findUnique({
      where: { id },
    });

    if (!group) {
      return NextResponse.json({ error: "Group not found" }, { status: 404 });
    }

    // Check if user is already a member
    const existingMembership = await prisma.groupsOnUsers.findUnique({
      where: {
        groupId_userId: {
          groupId: id,
          userId: user.userId,
        },
      },
    });

    if (existingMembership) {
      return NextResponse.json(
        { error: "User is already a member of this group" },
        { status: 409 }
      );
    }

    // Add user to group
    await prisma.groupsOnUsers.create({
      data: {
        groupId: id,
        userId: user.userId,
      },
    });

    return NextResponse.json(
      { message: "Successfully joined group" },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error joining group:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/groups/[id]/leave/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function POST(request, { params }) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Await params before accessing its properties
    const resolvedParams = await params;
    const { id } = resolvedParams;

    // Check if group exists
    const group = await prisma.group.findUnique({
      where: { id },
    });

    if (!group) {
      return NextResponse.json({ error: "Group not found" }, { status: 404 });
    }

    // Check if user is a member
    const membership = await prisma.groupsOnUsers.findUnique({
      where: {
        groupId_userId: {
          groupId: id,
          userId: user.userId,
        },
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "User is not a member of this group" },
        { status: 404 }
      );
    }

    // Check if user is the owner
    if (group.ownerId === user.userId) {
      return NextResponse.json(
        { error: "Group owner cannot leave the group" },
        { status: 400 }
      );
    }

    // Remove user from group
    await prisma.groupsOnUsers.delete({
      where: {
        groupId_userId: {
          groupId: id,
          userId: user.userId,
        },
      },
    });

    return NextResponse.json(
      { message: "Successfully left group" },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error leaving group:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/groups/check/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const name = searchParams.get("name");

  if (!name) {
    return NextResponse.json(
      { error: "Group name is required" },
      { status: 400 }
    );
  }

  try {
    const group = await prisma.group.findUnique({
      where: { name },
      select: { id: true },
    });

    return NextResponse.json({
      exists: !!group,
    });
  } catch (error) {
    console.error("Error checking group name:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/groups/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";
import { z } from "zod";

// Define validation schema
const groupSchema = z.object({
  name: z
    .string()
    .min(3)
    .max(21)
    .regex(/^[a-zA-Z0-9_]+$/),
  description: z.string().max(500).optional(),
});

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const search = searchParams.get("search");

  try {
    let whereClause = {};

    if (search) {
      whereClause = {
        name: {
          contains: search,
        },
      };
    }

    const groups = await prisma.group.findMany({
      where: whereClause,
      include: {
        _count: {
          select: {
            members: true,
            posts: true,
          },
        },
      },
      orderBy: {
        members: {
          _count: "desc",
        },
      },
      take: 50,
    });

    return NextResponse.json({ groups });
  } catch (error) {
    console.error("Error fetching groups:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();

    // Validate request data
    const result = groupSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { name, description } = body;

    // Check if group name is already taken
    const existingGroup = await prisma.group.findUnique({
      where: { name },
    });

    if (existingGroup) {
      return NextResponse.json(
        { error: "group name already exists" },
        { status: 409 }
      );
    }

    // Create group
    const group = await prisma.group.create({
      data: {
        name,
        description,
        ownerId: user.userId,
        members: {
          create: {
            userId: user.userId,
          },
        },
      },
    });

    return NextResponse.json(
      { message: "Group created successfully", group },
      { status: 201 }
    );
  } catch (error) {
    console.error("Error creating group:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/posts/friends/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function GET(request) {
  try {
    // Verify user is authenticated
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "10");
    const skip = (page - 1) * limit;

    // Get all friends (both directions of friendship)
    const friendships = await prisma.friendship.findMany({
      where: {
        OR: [{ userId: user.userId }, { friendId: user.userId }],
      },
      select: {
        userId: true,
        friendId: true,
      },
    });

    // Extract all friend IDs (from both directions)
    const friendIds = friendships
      .flatMap((friendship) => [
        friendship.userId === user.userId ? friendship.friendId : null,
        friendship.friendId === user.userId ? friendship.userId : null,
      ])
      .filter(Boolean);

    // If user has no friends, return empty array
    if (friendIds.length === 0) {
      return NextResponse.json({
        posts: [],
        pagination: {
          page,
          limit,
          totalCount: 0,
          totalPages: 0,
        },
      });
    }

    // Get posts from friends
    const posts = await prisma.post.findMany({
      where: {
        authorId: {
          in: friendIds,
        },
      },
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
        _count: {
          select: {
            comments: true,
            votes: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc", // Most recent first
      },
      skip,
      take: limit,
    });

    // Get total count for pagination
    const totalCount = await prisma.post.count({
      where: {
        authorId: {
          in: friendIds,
        },
      },
    });

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching friends' posts:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/posts/popular/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "25");
  const period = searchParams.get("period") || "week"; // day, week, month, all
  const skip = (page - 1) * limit;

  try {
    // Calculate the date range based on the period
    let dateFilter = {};
    const now = new Date();

    if (period === "day") {
      const oneDayAgo = new Date(now);
      oneDayAgo.setDate(now.getDate() - 1);
      dateFilter = {
        createdAt: {
          gte: oneDayAgo,
        },
      };
    } else if (period === "week") {
      const oneWeekAgo = new Date(now);
      oneWeekAgo.setDate(now.getDate() - 7);
      dateFilter = {
        createdAt: {
          gte: oneWeekAgo,
        },
      };
    } else if (period === "month") {
      const oneMonthAgo = new Date(now);
      oneMonthAgo.setMonth(now.getMonth() - 1);
      dateFilter = {
        createdAt: {
          gte: oneMonthAgo,
        },
      };
    }

    // First, get posts with their votes to calculate the score
    const posts = await prisma.post.findMany({
      where: dateFilter,
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
        votes: true,
        _count: {
          select: {
            comments: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Calculate vote score for each post
    const postsWithScores = posts.map((post) => {
      const score = post.votes.reduce((acc, vote) => acc + vote.value, 0);
      const { votes, ...postWithoutVotes } = post;
      return {
        ...postWithoutVotes,
        score,
        _count: {
          ...post._count,
          votes: votes.length,
        },
      };
    });

    // Sort by score
    const sortedPosts = postsWithScores.sort((a, b) => b.score - a.score);

    // Apply pagination
    const paginatedPosts = sortedPosts.slice(skip, skip + limit);

    // Calculate total for pagination
    const totalCount = sortedPosts.length;

    return NextResponse.json({
      posts: paginatedPosts,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching popular posts:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/posts/recent/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "25");
  const skip = (page - 1) * limit;

  try {
    const posts = await prisma.post.findMany({
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
        _count: {
          select: {
            comments: true,
            votes: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc", // Sort by newest first
      },
      skip,
      take: limit,
    });

    // Calculate total count for pagination
    const totalCount = await prisma.post.count();

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching recent posts:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/posts/search/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q");
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "20");
  const skip = (page - 1) * limit;

  if (!query) {
    return NextResponse.json(
      { error: "Search query is required" },
      { status: 400 }
    );
  }

  try {
    const posts = await prisma.post.findMany({
      where: {
        OR: [
          {
            title: {
              contains: query,
              mode: "insensitive",
            },
          },
          {
            content: {
              contains: query,
              mode: "insensitive",
            },
          },
        ],
      },
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
        _count: {
          select: {
            comments: true,
            votes: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
      skip,
      take: limit,
    });

    // Calculate total count for pagination
    const totalCount = await prisma.post.count({
      where: {
        OR: [
          {
            title: {
              contains: query,
              mode: "insensitive",
            },
          },
          {
            content: {
              contains: query,
              mode: "insensitive",
            },
          },
        ],
      },
    });

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error searching posts:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/posts/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";
import { z } from "zod";

// Define validation schema
const postSchema = z.object({
  title: z.string().min(3).max(300),
  content: z.string().optional(),
  groupId: z.string().min(1),
});

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const groupId = searchParams.get("groupId");
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "25");
  const skip = (page - 1) * limit;

  try {
    const whereClause = {};
    if (groupId) {
      whereClause.groupId = groupId;
    }

    const posts = await prisma.post.findMany({
      where: whereClause,
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
        _count: {
          select: {
            comments: true,
            votes: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
      skip,
      take: limit,
    });

    // Calculate total count for pagination
    const totalCount = await prisma.post.count({
      where: whereClause,
    });

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching posts:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();

    // Validate request data
    const result = postSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { title, content, groupId } = body;

    // Check if group exists
    const group = await prisma.group.findUnique({
      where: { id: groupId },
    });

    if (!group) {
      return NextResponse.json({ error: "Group not found" }, { status: 404 });
    }

    // Create post
    const post = await prisma.post.create({
      data: {
        title,
        content,
        authorId: user.userId,
        groupId,
      },
      include: {
        author: {
          select: {
            username: true,
          },
        },
        group: {
          select: {
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      { message: "Post created successfully", post },
      { status: 201 }
    );
  } catch (error) {
    console.error("Error creating post:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/[username]/friend/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function POST(request, { params }) {
  try {
    // Await params before using its properties
    const resolvedParams = await params;
    const { username } = resolvedParams;

    const currentUser = await getUserFromToken(request);

    if (!currentUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { action } = body;

    if (!["add", "remove"].includes(action)) {
      return NextResponse.json(
        { error: "Invalid action. Must be 'add' or 'remove'" },
        { status: 400 }
      );
    }

    // Get the target user
    const targetUser = await prisma.user.findUnique({
      where: { username },
      select: { id: true },
    });

    if (!targetUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Check if trying to add self as friend
    if (targetUser.id === currentUser.userId) {
      return NextResponse.json(
        { error: "Cannot add yourself as a friend" },
        { status: 400 }
      );
    }

    // Check if friendship already exists
    // Check if the friendship already exists using the composite unique constraint
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        AND: [{ userId: currentUser.userId }, { friendId: targetUser.id }],
      },
    });

    if (action === "add") {
      // Add friend
      if (existingFriendship) {
        return NextResponse.json(
          { error: "Already friends with this user" },
          { status: 409 }
        );
      }

      await prisma.friendship.create({
        data: {
          userId: currentUser.userId,
          friendId: targetUser.id,
        },
      });

      return NextResponse.json(
        { message: "Friend added successfully" },
        { status: 200 }
      );
    } else {
      // Remove friend
      if (!existingFriendship) {
        return NextResponse.json(
          { error: "Not friends with this user" },
          { status: 404 }
        );
      }

      await prisma.friendship.delete({
        where: {
          id: existingFriendship.id,
        },
      });

      return NextResponse.json(
        { message: "Friend removed successfully" },
        { status: 200 }
      );
    }
  } catch (error) {
    console.error("Friend action error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/[username]/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function GET(request, { params }) {
  // Await params before using its properties
  const resolvedParams = await params;
  const username = resolvedParams.username;

  try {
    // Get the user profile
    const user = await prisma.user.findUnique({
      where: { username },
      select: {
        id: true,
        username: true,
        createdAt: true,
        posts: {
          select: {
            id: true,
            title: true,
            createdAt: true,
            group: {
              select: {
                name: true,
              },
            },
            _count: {
              select: {
                comments: true,
                votes: true,
              },
            },
          },
          orderBy: {
            createdAt: "desc",
          },
        },
        comments: {
          select: {
            id: true,
            content: true,
            createdAt: true,
            post: {
              select: {
                id: true,
                title: true,
                group: {
                  select: {
                    name: true,
                  },
                },
              },
            },
          },
          orderBy: {
            createdAt: "desc",
          },
          take: 10,
        },
        // Get friends that the user has added
        friendsAdded: {
          select: {
            friend: {
              select: {
                id: true,
                username: true,
              },
            },
          },
        },
        // Get users who have added this user as a friend
        friendsOf: {
          select: {
            user: {
              select: {
                id: true,
                username: true,
              },
            },
          },
        },
      },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Transform friendsAdded and friendsOf into a single friends array
    const friends = [
      ...user.friendsAdded.map((relation) => relation.friend),
      ...user.friendsOf.map((relation) => relation.user),
    ];

    // Remove the original friendsAdded and friendsOf and add the combined friends
    const { friendsAdded, friendsOf, ...userWithoutFriendRelations } = user;
    const userWithFriends = {
      ...userWithoutFriendRelations,
      friends,
    };

    // Check if the requester is logged in
    const requestUser = await getUserFromToken(request);

    // Get upvoted and downvoted content
    // Important: We're now making this available regardless of who's viewing the profile
    // This is for demo purposes - in a production app, you'd likely want privacy controls
    const upvotedContent = await getVotedContent(user.id, 1);
    const downvotedContent = await getVotedContent(user.id, -1);

    // Add the upvoted and downvoted content to the user object
    userWithFriends.upvotedContent = upvotedContent;
    userWithFriends.downvotedContent = downvotedContent;

    return NextResponse.json(userWithFriends);
  } catch (error) {
    console.error("Error fetching user:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to get voted content (posts and comments)
async function getVotedContent(userId, voteValue) {
  try {
    // Get votes with the specified value
    const votes = await prisma.vote.findMany({
      where: {
        userId: userId,
        value: voteValue,
      },
      include: {
        post: {
          select: {
            id: true,
            title: true,
            createdAt: true,
            group: {
              select: {
                name: true,
              },
            },
          },
        },
        comment: {
          select: {
            id: true,
            content: true,
            createdAt: true,
            post: {
              select: {
                id: true,
                title: true,
                group: {
                  select: {
                    name: true,
                  },
                },
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Format the votes data for easier consumption by the frontend
    return votes
      .map((vote) => {
        if (vote.post) {
          return {
            ...vote.post,
            type: "post",
          };
        } else if (vote.comment) {
          return {
            ...vote.comment,
            type: "comment",
          };
        }
        return null;
      })
      .filter(Boolean);
  } catch (error) {
    console.error("Error getting voted content:", error);
    return [];
  }
}

================
File: src/app/api/users/search/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q");
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "20");
  const skip = (page - 1) * limit;

  if (!query) {
    return NextResponse.json(
      { error: "Search query is required" },
      { status: 400 }
    );
  }

  try {
    const users = await prisma.user.findMany({
      where: {
        OR: [
          {
            username: {
              contains: query,
              mode: "insensitive",
            },
          },
          {
            email: {
              contains: query,
              mode: "insensitive",
            },
          },
        ],
      },
      select: {
        id: true,
        username: true,
        createdAt: true,
        _count: {
          select: {
            posts: true,
            comments: true,
          },
        },
      },
      orderBy: {
        username: "asc",
      },
      skip,
      take: limit,
    });

    // Calculate total count for pagination
    const totalCount = await prisma.user.count({
      where: {
        OR: [
          {
            username: {
              contains: query,
              mode: "insensitive",
            },
          },
          {
            email: {
              contains: query,
              mode: "insensitive",
            },
          },
        ],
      },
    });

    return NextResponse.json({
      users,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/votes/score/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";

export async function GET(request) {
  try {
    const resolvedParams = new URL(request.url).searchParams;
    const postId = resolvedParams.get("postId");
    const commentId = resolvedParams.get("commentId");

    // User must provide either postId or commentId
    if (!postId && !commentId) {
      return NextResponse.json(
        { error: "Either postId or commentId is required" },
        { status: 400 }
      );
    }

    // Build where clause based on provided parameters
    const whereClause = {};

    if (postId) {
      whereClause.postId = postId;
    } else if (commentId) {
      whereClause.commentId = commentId;
    }

    // Find all votes for the content
    const votes = await prisma.vote.findMany({
      where: whereClause,
      select: {
        value: true,
      },
    });

    // Calculate the score (sum of vote values)
    const score = votes.reduce((total, vote) => total + vote.value, 0);

    return NextResponse.json({ score });
  } catch (error) {
    console.error("Error calculating vote score:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/votes/status/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";

export async function GET(request) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const postId = searchParams.get("postId");
    const commentId = searchParams.get("commentId");

    // User must provide either postId or commentId
    if (!postId && !commentId) {
      return NextResponse.json(
        { error: "Either postId or commentId is required" },
        { status: 400 }
      );
    }

    // Build where clause based on provided parameters
    const whereClause = {
      userId: user.userId,
    };

    if (postId) {
      whereClause.postId = postId;
    } else if (commentId) {
      whereClause.commentId = commentId;
    }

    // Get the vote
    const vote = await prisma.vote.findFirst({
      where: whereClause,
    });

    return NextResponse.json({ vote });
  } catch (error) {
    console.error("Error fetching vote status:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/votes/route.js
================
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { getUserFromToken } from "@/lib/utils";
import { z } from "zod";

// Define validation schema
const voteSchema = z
  .object({
    value: z.number().min(-1).max(1).int(),
    postId: z.string().optional(),
    commentId: z.string().optional(),
  })
  .refine((data) => data.postId || data.commentId, {
    message: "Either postId or commentId must be provided",
    path: ["postId", "commentId"],
  });

export async function POST(request) {
  try {
    const user = await getUserFromToken(request);
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();

    // Validate request data
    const result = voteSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input", details: result.error.flatten() },
        { status: 400 }
      );
    }

    const { value, postId, commentId } = body;

    // Check if the content (post or comment) exists
    if (postId) {
      const post = await prisma.post.findUnique({
        where: { id: postId },
      });

      if (!post) {
        return NextResponse.json({ error: "Post not found" }, { status: 404 });
      }
    }

    if (commentId) {
      const comment = await prisma.comment.findUnique({
        where: { id: commentId },
      });

      if (!comment) {
        return NextResponse.json(
          { error: "Comment not found" },
          { status: 404 }
        );
      }
    }

    // Check if user has already voted on this content
    const existingVote = await prisma.vote.findFirst({
      where: {
        userId: user.userId,
        postId,
        commentId,
      },
    });

    if (existingVote) {
      // Update existing vote
      if (value === 0) {
        // Remove vote if value is 0
        await prisma.vote.delete({
          where: { id: existingVote.id },
        });

        return NextResponse.json(
          { message: "Vote removed successfully" },
          { status: 200 }
        );
      } else {
        // Update vote value
        const updatedVote = await prisma.vote.update({
          where: { id: existingVote.id },
          data: { value },
        });

        return NextResponse.json(
          { message: "Vote updated successfully", vote: updatedVote },
          { status: 200 }
        );
      }
    } else if (value !== 0) {
      // Create new vote
      const vote = await prisma.vote.create({
        data: {
          value,
          userId: user.userId,
          postId,
          commentId,
        },
      });

      return NextResponse.json(
        { message: "Vote created successfully", vote },
        { status: 201 }
      );
    } else {
      // No existing vote and value is 0, nothing to do
      return NextResponse.json(
        { message: "No action required" },
        { status: 200 }
      );
    }
  } catch (error) {
    console.error("Error processing vote:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: src/app/auth/login/page.js
================
"use client";

import { useState } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { useAuth } from "@/components/auth/AuthContext";
import Button from "@/components/ui/Button";

export default function LoginPage() {
  const { login } = useAuth();
  const router = useRouter();
  const [formData, setFormData] = useState({
    usernameOrEmail: "",
    password: "",
  });
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    const { usernameOrEmail, password } = formData;

    try {
      const result = await login(usernameOrEmail, password);

      if (result.success) {
        router.push("/");
      } else {
        // Display the error message from the API
        setError(result.error || "Login failed. Please try again.");
      }
    } catch (err) {
      setError("An unexpected error occurred. Please try again.");
      console.error("Login error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto mt-8 p-6 bg-white rounded-lg shadow-md">
      <div className="flex flex-col items-cen mb-6">
        {/* Replace FaReddit with your custom logo */}
        <Image
          src="/logo.png"
          alt="CardiNet Logo"
          width={64}
          height={64}
          className="mb-2"
        />
        <h1 className="text-2xl font-bold">Log In</h1>
        <p className="text-gray-600 text-center mt-1">
          Welcome back to CardiNet
        </p>
      </div>

      {error && (
        <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-md">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label
            htmlFor="usernameOrEmail"
            className="block text-gray-700 font-medium mb-1"
          >
            Username or Email
          </label>
          <input
            type="text"
            id="usernameOrEmail"
            name="usernameOrEmail"
            value={formData.usernameOrEmail}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div className="mb-6">
          <label
            htmlFor="password"
            className="block text-gray-700 font-medium mb-1"
          >
            Password
          </label>
          <input
            type="password"
            id="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <Button
          type="submit"
          fullWidth
          isLoading={isLoading}
          disabled={isLoading}
        >
          Log In
        </Button>
      </form>

      <div className="mt-4 text-center">
        <p className="text-gray-600">
          Don&apos;t have an account?{" "}
          <Button href="/auth/register" variant="link">
            Sign Up
          </Button>
        </p>
      </div>
    </div>
  );
}

================
File: src/app/auth/register/page.js
================
"use client";

import { useState } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { useAuth } from "@/components/auth/AuthContext";

export default function RegisterPage() {
  const { register, login } = useAuth();
  const router = useRouter();
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    password: "",
    confirmPassword: "",
  });
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const validateForm = () => {
    if (formData.password !== formData.confirmPassword) {
      setError("Passwords do not match");
      return false;
    }

    if (formData.password.length < 8) {
      setError("Password must be at least 8 characters long");
      return false;
    }

    // Username validation: alphanumeric and underscore only
    if (!/^[a-zA-Z0-9_]+$/.test(formData.username)) {
      setError("Username can only contain letters, numbers, and underscores");
      return false;
    }

    if (formData.username.length < 3 || formData.username.length > 20) {
      setError("Username must be between 3 and 20 characters");
      return false;
    }

    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      const { username, email, password } = formData;
      const result = await register(username, email, password);

      if (result.success) {
        // Automatically log in the new user
        const loginResult = await login(email, password);

        if (loginResult.success) {
          router.push("/");
        } else {
          router.push("/auth/login?registered=true");
        }
      } else {
        setError(result.error || "Registration failed");
      }
    } catch (err) {
      setError("An unexpected error occurred. Please try again.");
      console.error("Registration error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto mt-8 p-6 bg-white rounded-lg shadow-md">
      <div className="flex flex-col items-center-6">
        <Image
          src="/logo.png"
          alt="CardiNet Logo"
          width={64}
          height={64}
          className="mb-2"
        />
        <h1 className="text-2xl font-bold">Create an Account</h1>
        <p className="text-gray-600 text-center mt-1">
          Join the CardiNet community
        </p>
      </div>

      {error && (
        <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-md">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label
            htmlFor="username"
            className="block text-gray-700 font-medium mb-1"
          >
            Username
          </label>
          <input
            type="text"
            id="username"
            name="username"
            value={formData.username}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div className="mb-4">
          <label
            htmlFor="email"
            className="block text-gray-700 font-medium mb-1"
          >
            Email
          </label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div className="mb-4">
          <label
            htmlFor="password"
            className="block text-gray-700 font-medium mb-1"
          >
            Password
          </label>
          <input
            type="password"
            id="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
          <p className="text-xs text-gray-500 mt-1">
            Must be at least 8 characters long
          </p>
        </div>

        <div className="mb-6">
          <label
            htmlFor="confirmPassword"
            className="block text-gray-700 font-medium mb-1"
          >
            Confirm Password
          </label>
          <input
            type="password"
            id="confirmPassword"
            name="confirmPassword"
            value={formData.confirmPassword}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <button
          type="submit"
          disabled={isLoading}
          className="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? "Creating Account..." : "Sign Up"}
        </button>
      </form>

      <div className="mt-4 text-center">
        <p className="text-gray-600">
          Already have an account?{" "}
          <Link href="/auth/login" className="text-blue-500 hover:underline">
            Log In
          </Link>
        </p>
      </div>
    </div>
  );
}

================
File: src/app/create/group/page.js
================
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/auth/AuthContext";
import { FaSpinner } from "react-icons/fa";
import Button from "@/components/ui/Button";

export default function CreateGroupPage() {
  const { user, isAuthenticated, loading } = useAuth();
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    description: "",
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [nameAvailable, setNameAvailable] = useState(null);
  const [isCheckingName, setIsCheckingName] = useState(false);

  // Redirect if not authenticated
  useEffect(() => {
    if (!loading && !isAuthenticated) {
      router.push("/auth/login?redirect=/create/group");
    }
  }, [isAuthenticated, loading, router]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));

    // Clear error when field is updated
    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: "",
      }));
    }

    // Reset name availability check when name changes
    if (name === "name") {
      setNameAvailable(null);
    }
  };

  const checkNameAvailability = async () => {
    const name = formData.name.trim();
    if (!name || !/^[a-zA-Z0-9_]+$/.test(name)) {
      return;
    }

    setIsCheckingName(true);
    try {
      const response = await fetch(`/api/groups/check?name=${name}`);
      const data = await response.json();
      setNameAvailable(!data.exists);
    } catch (error) {
      console.error("Error checking name availability:", error);
    } finally {
      setIsCheckingName(false);
    }
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = "Group name is required";
    } else if (formData.name.length < 3 || formData.name.length > 21) {
      newErrors.name = "Group name must be between 3 and 21 characters";
    } else if (!/^[a-zA-Z0-9_]+$/.test(formData.name)) {
      newErrors.name =
        "Group name can only contain letters, numbers, and underscores";
    }

    if (formData.description && formData.description.length > 500) {
      newErrors.description = "Description must be less than 500 characters";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("/api/groups", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: formData.name.trim(),
          description: formData.description.trim(),
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to create group");
      }

      const data = await response.json();

      // Redirect to the new group
      router.push(`/group/${data.group.name}`);
    } catch (error) {
      console.error("Group creation error:", error);
      setErrors((prev) => ({
        ...prev,
        form: error.message || "Failed to create group. Please try again.",
      }));
      setIsSubmitting(false);
    }
  };

  // Handle name availability check when user stops typing
  useEffect(() => {
    const timer = setTimeout(() => {
      if (formData.name.trim() && formData.name.length >= 3) {
        checkNameAvailability();
      }
    }, 500);

    return () => clearTimeout(timer);
  }, [formData.name]);

  if (loading || !isAuthenticated) {
    return (
      <div className="flex justify-center items-center py-20">
        <FaSpinner className="text-4xl text-gray-500 animate-spin" />
      </div>
    );
  }

  return (
    <div className="max-w-2xl mx-auto">
      <div className="bg-white rounded-md shadow-sm p-6">
        <div className="flex items-center mb-6">
          <h1 className="text-2xl font-bold">Create a Group</h1>
        </div>

        {errors.form && (
          <div className="mb-6 p-3 bg-red-100 text-red-700 rounded-md">
            {errors.form}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-6">
            <label
              htmlFor="name"
              className="block text-gray-700 font-medium mb-1"
            >
              Group Name
            </label>
            <div className="relative">
              <input
                type="text"
                id="name"
                name="name"
                value={formData.name}
                onChange={handleChange}
                placeholder="Group Name"
                className={`w-full pl-4 pr-10 py-2 border ${
                  errors.name ? "border-red-500" : "border-gray-300"
                } rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
                disabled={isSubmitting}
              />
              {isCheckingName && (
                <FaSpinner className="absolute right-3 top-3 text-gray-400 animate-spin" />
              )}
              {nameAvailable !== null && !isCheckingName && (
                <span
                  className={`absolute right-3 top-2 ${
                    nameAvailable ? "text-green-500" : "text-red-500"
                  }`}
                >
                  {nameAvailable ? "Available" : "Unavailable"}
                </span>
              )}
            </div>
            {errors.name && (
              <p className="mt-1 text-red-500 text-sm">{errors.name}</p>
            )}
            <p className="mt-1 text-xs text-gray-500">
              Group names must be between 3-21 characters, only contain letters,
              numbers, or underscores, and cannot be changed later.
            </p>
          </div>

          <div className="mb-6">
            <label
              htmlFor="description"
              className="block text-gray-700 font-medium mb-1"
            >
              Description (optional)
            </label>
            <textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleChange}
              placeholder="What is your group about?"
              rows={4}
              className={`w-full px-3 py-2 border ${
                errors.description ? "border-red-500" : "border-gray-300"
              } rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
              disabled={isSubmitting}
            />
            {errors.description && (
              <p className="mt-1 text-red-500 text-sm">{errors.description}</p>
            )}
            <p className="mt-1 text-xs text-gray-500">Max 500 characters</p>
          </div>

          <hr className="my-6 border-gray-200" />

          <div className="flex justify-end space-x-3">
            <Button
              type="button"
              onClick={() => router.back()}
              disabled={isSubmitting}
              variant="secondary"
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={isSubmitting || nameAvailable === false}
            >
              {isSubmitting ? (
                <span className="flex items-center">
                  <FaSpinner className="animate-spin mr-2" /> Creating...
                </span>
              ) : (
                "Create Group"
              )}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}

================
File: src/app/create/post/page.js
================
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/auth/AuthContext";
import Button from "@/components/ui/Button";
import { FaPlus } from "react-icons/fa";

export default function CreatePostPage() {
  const { user, isAuthenticated, loading } = useAuth();
  const router = useRouter();
  const [formData, setFormData] = useState({
    title: "",
    content: "",
    groupId: "",
  });
  const [groups, setGroups] = useState([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});
  const [loadingGroups, setLoadingGroups] = useState(true);

  // Redirect if not authenticated
  useEffect(() => {
    if (!loading && !isAuthenticated) {
      router.push("/auth/login?redirect=/create/post");
    }
  }, [isAuthenticated, loading, router]);

  // Fetch groups
  useEffect(() => {
    const fetchGroups = async () => {
      try {
        setLoadingGroups(true);
        const response = await fetch("/api/groups");

        if (!response.ok) {
          throw new Error("Failed to fetch groups");
        }

        const data = await response.json();
        setGroups(data.groups);
      } catch (err) {
        console.error("Error fetching groups:", err);
      } finally {
        setLoadingGroups(false);
      }
    };

    if (isAuthenticated) {
      fetchGroups();
    }
  }, [isAuthenticated]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));

    // Clear error when field is updated
    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: "",
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.title.trim()) {
      newErrors.title = "Title is required";
    } else if (formData.title.length > 300) {
      newErrors.title = "Title must be less than 300 characters";
    }

    if (!formData.groupId) {
      newErrors.groupId = "Please select a group";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("/api/posts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to create post");
      }

      const data = await response.json();

      // Redirect to the new post
      const group = groups.find((g) => g.id === formData.groupId);
      router.push(`/group/${group.name}/comments/${data.post.id}`);
    } catch (err) {
      console.error("Post creation error:", err);
      setErrors((prev) => ({
        ...prev,
        form: err.message || "Failed to create post. Please try again.",
      }));
      setIsSubmitting(false);
    }
  };

  if (loading || !isAuthenticated) {
    return (
      <div className="flex justify-center items-center py-20">
        <Button isLoading>Loading</Button>
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto">
      <div className="bg-white rounded-md shadow-sm p-6">
        <h1 className="text-2xl font-bold mb-6">Create a Post</h1>

        {errors.form && (
          <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-md">
            {errors.form}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label
              htmlFor="groupId"
              className="block text-gray-700 font-medium mb-1"
            >
              Choose a group
            </label>
            <select
              id="groupId"
              name="groupId"
              value={formData.groupId}
              onChange={handleChange}
              className={`w-full px-3 py-2 border ${
                errors.groupId ? "border-red-500" : "border-gray-300"
              } rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
              disabled={isSubmitting || loadingGroups}
            >
              <option value="">Select a group</option>
              {groups.map((group) => (
                <option key={group.id} value={group.id}>
                  {group.name}
                </option>
              ))}
            </select>
            {errors.groupId && (
              <p className="mt-1 text-red-500 text-sm">{errors.groupId}</p>
            )}
            {loadingGroups && (
              <p className="mt-1 text-gray-500 text-sm flex items-center">
                <Button size="sm" isLoading>
                  Loading groups...
                </Button>
              </p>
            )}
          </div>

          <div className="mb-4">
            <label
              htmlFor="title"
              className="block text-gray-700 font-medium mb-1"
            >
              Title
            </label>
            <input
              type="text"
              id="title"
              name="title"
              value={formData.title}
              onChange={handleChange}
              placeholder="Title"
              className={`w-full px-3 py-2 border ${
                errors.title ? "border-red-500" : "border-gray-300"
              } rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
              disabled={isSubmitting}
            />
            {errors.title && (
              <p className="mt-1 text-red-500 text-sm">{errors.title}</p>
            )}
          </div>

          <div className="mb-6">
            <label
              htmlFor="content"
              className="block text-gray-700 font-medium mb-1"
            >
              Text (optional)
            </label>
            <textarea
              id="content"
              name="content"
              value={formData.content}
              onChange={handleChange}
              placeholder="Text (optional)"
              rows={8}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isSubmitting}
            />
          </div>

          <div className="flex justify-end space-x-3">
            <Button
              variant="secondary"
              onClick={() => router.back()}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              variant="primary"
              icon={<FaPlus />}
              isLoading={isSubmitting}
              disabled={isSubmitting}
            >
              Post
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}

================
File: src/app/explore/page.js
================
import RecentPosts from "@/components/post/RecentPosts";

export const metadata = {
  title: "Explore - CardiNet",
  description: "Discover the most recent posts across all groups",
};

export default function ExplorePage() {
  return <RecentPosts />;
}

================
File: src/app/friends/page.js
================
import FriendsPosts from "@/components/post/FriendsPosts";

export const metadata = {
  title: "Friends Feed - CardiNet",
  description: "See posts from people you follow",
};

export default function FriendsPage() {
  return <FriendsPosts />;
}

================
File: src/app/group/[group]/comments/[postId]/page.js
================
import { notFound } from "next/navigation";
import prisma from "@/lib/db";
import PostItem from "@/components/post/PostItem";
import CommentSection from "@/components/comment/CommentSection";

export async function generateMetadata({ params }) {
  // Await params before accessing its properties
  const resolvedParams = await params;
  const { postId } = resolvedParams;

  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      group: true,
    },
  });

  if (!post) {
    return {
      title: "Post Not Found",
    };
  }

  return {
    title: post.title,
    description:
      post.content?.substring(0, 160) || `A post in ${post.group.name}`,
  };
}

export default async function PostDetailPage({ params }) {
  // Await params before accessing its properties
  const resolvedParams = await params;
  const { postId, group: groupParam } = resolvedParams;

  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      author: {
        select: {
          username: true,
        },
      },
      group: true,
      _count: {
        select: {
          comments: true,
          votes: true,
        },
      },
    },
  });

  if (!post) {
    notFound();
  }

  // Extract group name from either the post data or the URL param
  const groupName = post.group.name || groupParam;

  return (
    <div>
      <PostItem post={post} isDetailView={true} />

      <div className="mt-4">
        <CommentSection postId={post.id} groupName={groupName} />
      </div>
    </div>
  );
}

================
File: src/app/group/[group]/page.js
================
import { notFound } from "next/navigation";
import prisma from "@/lib/db";
import GroupHeader from "@/components/group/GroupHeader";
import PostList from "@/components/post/PostList";

export async function generateMetadata({ params }) {
  const resolvedParams = await params;
  const groupName = resolvedParams.group;

  const group = await prisma.group.findUnique({
    where: { name: groupName },
  });

  if (!group) {
    return {
      title: "Group Not Found",
    };
  }

  return {
    title: `${groupName} - CardiNet`,
    description:
      group.description || `Welcome to the ${groupName} group on CardiNet`,
  };
}

export default async function groupPage({ params }) {
  const resolvedParams = await params;
  const groupName = resolvedParams.group;

  const group = await prisma.group.findUnique({
    where: { name: groupName },
    include: {
      owner: {
        select: {
          username: true,
        },
      },
      _count: {
        select: {
          members: true,
          posts: true,
        },
      },
    },
  });

  if (!group) {
    notFound();
  }

  return (
    <div>
      <GroupHeader group={group} />

      <div className="mt-4">
        <PostList groupId={group.id} />
      </div>
    </div>
  );
}

================
File: src/app/popular/page.js
================
import PopularPosts from "@/components/post/PopularPosts";

export const metadata = {
  title: "Popular Posts - CardiNet",
  description: "See the most upvoted posts across all groups",
};

export default function PopularPage() {
  return <PopularPosts />;
}

================
File: src/app/search/page.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { useSearchParams } from "next/navigation";
import { FaSpinner, FaArrowUp, FaComment } from "react-icons/fa";
import { formatRelativeTime, generateGroupColor } from "@/lib/utils";

export default function SearchPage() {
  const searchParams = useSearchParams();
  const query = searchParams.get("q") || "";

  const [groups, setGroups] = useState([]);
  const [posts, setPosts] = useState([]);
  const [users, setUsers] = useState([]);
  const [activeTab, setActiveTab] = useState("groups");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query.trim()) {
      setLoading(false);
      return;
    }

    const fetchResults = async () => {
      try {
        setLoading(true);

        // Fetch groups matching the query
        const groupsResponse = await fetch(`/api/groups?search=${query}`);

        if (!groupsResponse.ok) {
          throw new Error("Failed to fetch groups");
        }

        const groupsData = await groupsResponse.json();
        setGroups(groupsData.groups);

        // Fetch posts matching the query
        const postsResponse = await fetch(`/api/posts/search?q=${query}`);

        if (!postsResponse.ok) {
          throw new Error("Failed to fetch posts");
        }

        const postsData = await postsResponse.json();
        setPosts(postsData.posts);

        // Fetch users matching the query
        const usersResponse = await fetch(`/api/users/search?q=${query}`);

        if (!usersResponse.ok) {
          throw new Error("Failed to fetch users");
        }

        const usersData = await usersResponse.json();
        setUsers(usersData.users);

        // Set default active tab based on results
        if (groupsData.groups.length === 0) {
          if (postsData.posts.length > 0) {
            setActiveTab("posts");
          } else if (usersData.users.length > 0) {
            setActiveTab("users");
          }
        }
      } catch (err) {
        console.error("Search error:", err);
        setError("Failed to perform search. Please try again later.");
      } finally {
        setLoading(false);
      }
    };

    fetchResults();
  }, [query]);

  if (!query.trim()) {
    return (
      <div className="max-w-4xl mx-auto text-center py-16">
        <h1 className="text-2xl font-bold mb-4">Search CardiNet</h1>
        <p className="text-gray-600">
          Enter a search term in the search box above to find groups and posts.
        </p>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="max-w-4xl mx-auto flex justify-center py-16">
        <FaSpinner className="text-3xl text-gray-500 animate-spin" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-4xl mx-auto py-8">
        <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>
      </div>
    );
  }

  const noResults =
    groups.length === 0 && posts.length === 0 && users.length === 0;

  return (
    <div className="max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">Search results for: "{query}"</h1>

      {noResults ? (
        <div className="bg-white rounded-md shadow-sm p-8 text-center">
          <h2 className="text-lg font-semibold mb-2">No results found</h2>
          <p className="text-gray-600">
            We couldn't find any groups or posts matching your search.
          </p>
        </div>
      ) : (
        <>
          {/* Tabs */}
          <div className="bg-white rounded-md shadow-sm mb-6">
            <div className="flex border-b border-gray-200">
              <button
                onClick={() => setActiveTab("groups")}
                className={`px-4 py-2 font-medium ${
                  activeTab === "groups"
                    ? "text-blue-500 border-b-2 border-blue-500"
                    : "text-gray-500 hover:text-gray-700"
                }`}
              >
                Groups ({groups.length})
              </button>
              <button
                onClick={() => setActiveTab("posts")}
                className={`px-4 py-2 font-medium ${
                  activeTab === "posts"
                    ? "text-blue-500 border-b-2 border-blue-500"
                    : "text-gray-500 hover:text-gray-700"
                }`}
              >
                Posts ({posts.length})
              </button>
              <button
                onClick={() => setActiveTab("users")}
                className={`px-4 py-2 font-medium ${
                  activeTab === "users"
                    ? "text-blue-500 border-b-2 border-blue-500"
                    : "text-gray-500 hover:text-gray-700"
                }`}
              >
                Users ({users.length})
              </button>
            </div>

            {/* Results */}
            <div className="p-4">
              {activeTab === "groups" && (
                <div className="space-y-4">
                  {groups.length === 0 ? (
                    <p className="text-center py-4 text-gray-500">
                      No groups found.
                    </p>
                  ) : (
                    groups.map((group) => (
                      <Link
                        key={group.id}
                        href={`/group/${group.name}`}
                        className="flex items-center p-3 hover:bg-gray-50 rounded-md border border-gray-200"
                      >
                        <div
                          className={`w-10 h-10 rounded-full ${generateGroupColor(
                            group.name
                          )} flex items-center justify-center mr-3`}
                        >
                          {/* Replace FaReddit with your custom logo icon */}
                          <Image
                            src="/logo-icon.png"
                            alt="Group"
                            width={20}
                            height={20}
                            className="text-white text-xl"
                          />
                        </div>
                        <div>
                          <h3 className="font-medium">{group.name}</h3>
                          <p className="text-sm text-gray-500">
                            {group._count.members}{" "}
                            {group._count.members === 1 ? "member" : "members"}{" "}
                            • {group._count.posts}{" "}
                            {group._count.posts === 1 ? "post" : "posts"}
                          </p>
                          {group.description && (
                            <p className="text-sm text-gray-700 mt-1">
                              {group.description}
                            </p>
                          )}
                        </div>
                      </Link>
                    ))
                  )}
                </div>
              )}

              {activeTab === "posts" && (
                <div className="space-y-4">
                  {posts.length === 0 ? (
                    <p className="text-center py-4 text-gray-500">
                      No posts found.
                    </p>
                  ) : (
                    posts.map((post) => (
                      <div
                        key={post.id}
                        className="p-3 hover:bg-gray-50 rounded-md border border-gray-200"
                      >
                        <div className="text-xs text-gray-500 mb-1">
                          Posted in{" "}
                          <Link
                            href={`/group/${post.group.name}`}
                            className="text-blue-500 hover:underline"
                          >
                            {post.group.name}
                          </Link>{" "}
                          by{" "}
                          <Link
                            href={`/${post.author.username}`}
                            className="hover:underline"
                          >
                            {post.author.username}
                          </Link>{" "}
                          {formatRelativeTime(post.createdAt)}
                        </div>
                        <h3 className="text-lg font-medium mb-2">
                          <Link
                            href={`/group/${post.group.name}/comments/${post.id}`}
                            className="hover:underline"
                          >
                            {post.title}
                          </Link>
                        </h3>
                        {post.content && (
                          <p className="text-gray-800 mb-2 line-clamp-2">
                            {post.content}
                          </p>
                        )}
                        <div className="flex items-center text-gray-500 text-sm">
                          <div className="flex items-center mr-4">
                            <FaArrowUp className="mr-1" />
                            <span>{post._count?.votes || 0} votes</span>
                          </div>
                          <div className="flex items-center mr-4">
                            <FaComment className="mr-1" />
                            <span>{post._count?.comments || 0} comments</span>
                          </div>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              )}

              {activeTab === "users" && (
                <div className="space-y-4">
                  {users.length === 0 ? (
                    <p className="text-center py-4 text-gray-500">
                      No users found.
                    </p>
                  ) : (
                    users.map((user) => (
                      <Link
                        key={user.id}
                        href={`/${user.username}`}
                        className="flex items-center p-3 hover:bg-gray-50 rounded-md border border-gray-200"
                      >
                        <div className="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold mr-3">
                          {user.username.slice(0, 1).toUpperCase()}
                        </div>
                        <div>
                          <h3 className="font-medium">{user.username}</h3>
                          <p className="text-sm text-gray-500">
                            {user.createdAt &&
                              `Member since ${new Date(
                                user.createdAt
                              ).toLocaleDateString()}`}
                          </p>
                          <div className="flex items-center text-xs text-gray-500 mt-1">
                            <span className="mr-3">
                              {user._count.posts} posts
                            </span>
                            <span>{user._count.comments} comments</span>
                          </div>
                        </div>
                      </Link>
                    ))
                  )}
                </div>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
}

================
File: src/app/user/[username]/client.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import {
  FaCalendarAlt,
  FaComment,
  FaArrowUp,
  FaUser,
  FaUserFriends,
  FaUserPlus,
  FaUserMinus,
} from "react-icons/fa";
import { formatDate, formatRelativeTime } from "@/lib/utils";
import Button from "@/components/ui/Button";

export default function UserProfileClient({ params }) {
  const { username } = params;
  const [user, setUser] = useState(null);
  const [currentUser, setCurrentUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState("posts");
  const [isFriend, setIsFriend] = useState(false);
  const [isProcessingFriend, setIsProcessingFriend] = useState(false);

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        setLoading(true);

        // Fetch profile user data
        const response = await fetch(`/api/users/${username}`);

        if (!response.ok) {
          throw new Error("Failed to fetch user data");
        }

        const userData = await response.json();
        setUser(userData);

        // Check if logged in user data exists in local storage
        const storedUser = localStorage.getItem("user");
        if (storedUser) {
          const parsedUser = JSON.parse(storedUser);
          setCurrentUser(parsedUser);

          // Check if viewed user is a friend
          if (userData.friends) {
            setIsFriend(
              userData.friends.some((friend) => friend.id === parsedUser.id)
            );
          }
        }
      } catch (err) {
        console.error("Error fetching user data:", err);
        setError("Failed to load user profile. Please try again later.");
      } finally {
        setLoading(false);
      }
    };

    fetchUserData();
  }, [username]);

  const handleTabChange = (tab) => {
    setActiveTab(tab);
  };

  const handleFriendAction = async (action) => {
    if (!currentUser) {
      window.location.href = "/auth/login";
      return;
    }

    setIsProcessingFriend(true);

    try {
      const response = await fetch(`/api/users/${username}/friend`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ action }),
      });

      if (!response.ok) {
        throw new Error(`Failed to ${action} friend`);
      }

      // Update UI state
      setIsFriend(action === "add");
    } catch (err) {
      console.error(`Friend ${action} error:`, err);
      // Could add a toast notification here
    } finally {
      setIsProcessingFriend(false);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center py-20">
        <Button isLoading>Loading profile</Button>
      </div>
    );
  }

  if (error || !user) {
    return (
      <div className="max-w-4xl mx-auto py-8">
        <div className="bg-red-50 text-red-700 p-4 rounded-md">
          {error || "User not found"}
        </div>
      </div>
    );
  }

  // Check if content arrays exist - if not, provide empty arrays as fallbacks
  const upvotedContent = user.upvotedContent || [];
  const downvotedContent = user.downvotedContent || [];
  const userPosts = user.posts || [];
  const userComments = user.comments || [];

  return (
    <div className="max-w-4xl mx-auto">
      {/* Profile header */}
      <div className="bg-white rounded-md shadow-sm p-6 mb-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <div className="w-16 h-16 bg-blue-500 rounded-full flex items-center justify-center text-white text-2xl font-bold">
              {username.slice(0, 1).toUpperCase()}
            </div>
            <div className="ml-4">
              <h1 className="text-2xl font-bold">{username}</h1>
              <div className="flex items-center text-gray-500 text-sm mt-1">
                <FaCalendarAlt className="mr-1" />
                <span>Account created {formatDate(user.createdAt)}</span>
              </div>
            </div>
          </div>

          {/* Friend Button (only shows if not viewing own profile) */}
          {currentUser && currentUser.username !== username && (
            <div>
              {isFriend ? (
                <Button
                  variant="secondary"
                  onClick={() => handleFriendAction("remove")}
                  isLoading={isProcessingFriend}
                  icon={<FaUserMinus />}
                >
                  Remove Friend
                </Button>
              ) : (
                <Button
                  variant="primary"
                  onClick={() => handleFriendAction("add")}
                  isLoading={isProcessingFriend}
                  icon={<FaUserPlus />}
                >
                  Add Friend
                </Button>
              )}
            </div>
          )}
        </div>
      </div>

      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-2/3">
          {/* Content tabs */}
          <div className="bg-white rounded-md shadow-sm mb-6">
            <div className="border-b border-gray-200">
              <nav className="flex flex-wrap">
                <button
                  className={`px-4 py-2 ${
                    activeTab === "posts"
                      ? "text-blue-500 border-b-2 border-blue-500 font-medium"
                      : "text-gray-500 hover:text-gray-700"
                  }`}
                  onClick={() => handleTabChange("posts")}
                >
                  Posts
                </button>
                <button
                  className={`px-4 py-2 ${
                    activeTab === "comments"
                      ? "text-blue-500 border-b-2 border-blue-500 font-medium"
                      : "text-gray-500 hover:text-gray-700"
                  }`}
                  onClick={() => handleTabChange("comments")}
                >
                  Comments
                </button>
                <button
                  className={`px-4 py-2 ${
                    activeTab === "upvoted"
                      ? "text-blue-500 border-b-2 border-blue-500 font-medium"
                      : "text-gray-500 hover:text-gray-700"
                  }`}
                  onClick={() => handleTabChange("upvoted")}
                >
                  Upvoted
                </button>
                <button
                  className={`px-4 py-2 ${
                    activeTab === "downvoted"
                      ? "text-blue-500 border-b-2 border-blue-500 font-medium"
                      : "text-gray-500 hover:text-gray-700"
                  }`}
                  onClick={() => handleTabChange("downvoted")}
                >
                  Downvoted
                </button>
              </nav>
            </div>

            {/* Display content based on active tab */}
            {activeTab === "posts" && (
              <div className="p-4">
                {userPosts.length === 0 ? (
                  <div className="text-center py-8 text-gray-500">
                    <p>No posts yet</p>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {userPosts.map((post) => (
                      <div
                        key={post.id}
                        className="border border-gray-200 rounded-md p-4"
                      >
                        <div className="text-xs text-gray-500 mb-2">
                          Posted in{" "}
                          <Link
                            href={`/group/${post.group.name}`}
                            className="text-blue-500 hover:underline"
                          >
                            {post.group.name}
                          </Link>{" "}
                          • {formatRelativeTime(post.createdAt)}
                        </div>
                        <h2 className="text-lg font-medium mb-2">
                          <Link
                            href={`/group/${post.group.name}/comments/${post.id}`}
                            className="hover:underline"
                          >
                            {post.title}
                          </Link>
                        </h2>
                        <div className="flex items-center text-gray-500 text-sm mt-2">
                          <div className="flex items-center mr-4">
                            <FaArrowUp className="mr-1" />
                            <span>{post._count?.votes || 0} votes</span>
                          </div>
                          <div className="flex items-center mr-4">
                            <FaComment className="mr-1" />
                            <span>{post._count?.comments || 0} comments</span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* Other tab contents would be rendered here similarly */}
          </div>
        </div>

        {/* Friends List Sidebar */}
        <div className="md:w-1/3">
          <div className="bg-white rounded-md shadow-sm p-4 sticky top-4">
            <h2 className="text-lg font-semibold mb-3 flex items-center">
              <FaUserFriends className="mr-2 text-blue-500" />
              Friends
            </h2>

            {user.friends && user.friends.length > 0 ? (
              <div className="space-y-3">
                {user.friends.map((friend) => (
                  <Link
                    key={friend.id}
                    href={`/user/${friend.username}`}
                    className="flex items-center p-2 hover:bg-gray-100 rounded-md"
                  >
                    <div className="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold mr-2">
                      {friend.username.slice(0, 1).toUpperCase()}
                    </div>
                    <span className="font-medium">{friend.username}</span>
                  </Link>
                ))}
              </div>
            ) : (
              <p className="text-gray-500 text-sm">
                {username === currentUser?.username
                  ? "You haven't added any friends yet"
                  : "This user hasn't added any friends yet"}
              </p>
            )}

            {username === currentUser?.username && (
              <div className="mt-4">
                <Button
                  href="/explore"
                  variant="secondary"
                  fullWidth
                  icon={<FaUserPlus />}
                >
                  Find Friends
                </Button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/app/user/[username]/page.js
================
import { notFound } from "next/navigation";
import UserProfileClient from "./client";

export async function generateMetadata({ params }) {
  // Await params before using its properties
  const resolvedParams = await params;
  const username = resolvedParams.username;

  return {
    title: `${username} - Cardinet`,
    description: `User profile for ${username}`,
  };
}

export default async function UserProfilePage(props) {
  // Resolve props before passing to client component
  const resolvedProps = {
    ...props,
    params: await props.params,
    searchParams: await props.searchParams,
  };

  return <UserProfileClient {...resolvedProps} />;
}

================
File: src/app/globals.css
================
@import "tailwindcss";
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 124, 15, 15;
  --accent-rgb: 249, 221, 66;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

================
File: src/app/layout.js
================
import { Inter } from "next/font/google";
import "./globals.css";
import Header from "@/components/layout/Header";
import LeftSidebar from "@/components/layout/LeftSidebar";
import { AuthProvider } from "@/components/auth/AuthContext";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "CardiNet",
  description: "The Mapuan Social and Community Network",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body
        className={`${inter.className} min-h-screen flex flex-col bg-gray-100`}
      >
        <AuthProvider>
          <Header />
          <div className="flex-grow container mx-auto px-2 sm:px-4">
            <div className="flex">
              {/* Left Sidebar */}
              <LeftSidebar />

              {/* Divider */}
              <div className="border-l border-black h-screen sticky top-0"></div>

              {/* Main Content */}
              <main className="flex-grow p-4">{children}</main>
            </div>
          </div>
        </AuthProvider>
      </body>
    </html>
  );
}

================
File: src/app/page.js
================
import Link from "next/link";
import { FaReddit, FaPlus } from "react-icons/fa";
import PostList from "@/components/post/PostList";
import Button from "@/components/ui/Button";

export default async function Home() {
  return (
    <div>
      {/* Home welcome card */}
      <div className="bg-white rounded-md shadow-sm p-4 mb-6">
        <h2 className="text-lg font-semibold mb-3">Home</h2>
        <p className="text-gray-600 mb-4">
          Your personal CardiNet frontpage. Come here to check in with your
          favorite groups.
        </p>
        <Button
          href="/create/post"
          fullWidth
          variant="primary"
          icon={<FaPlus />}
        >
          Create Post
        </Button>
      </div>

      {/* Posts feed */}
      <PostList />
    </div>
  );
}

================
File: src/components/auth/AuthContext.js
================
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";

// Create the Auth context
const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    // Check if user data exists in local storage
    const storedUser = localStorage.getItem("user");
    if (storedUser) {
      try {
        setUser(JSON.parse(storedUser));
      } catch (error) {
        console.error("Failed to parse stored user data:", error);
        localStorage.removeItem("user");
      }
    }
    setLoading(false);
  }, []);

  const login = async (usernameOrEmail, password) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ usernameOrEmail, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Login failed");
      }

      // Save user to state and localStorage
      setUser(data.user);
      localStorage.setItem("user", JSON.stringify(data.user));

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const register = async (username, email, password) => {
    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ username, email, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Registration failed");
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const logout = async () => {
    try {
      // Clear cookie by making a request to logout endpoint
      await fetch("/api/auth/logout", {
        method: "POST",
      });

      // Clear user from state and localStorage
      setUser(null);
      localStorage.removeItem("user");

      // Redirect to home page
      router.push("/");
    } catch (error) {
      console.error("Logout failed:", error);
    }
  };

  // Create the context value object
  const value = {
    user,
    loading,
    login,
    register,
    logout,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Custom hook to use the Auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

================
File: src/components/comment/CommentForm.js
================
"use client";

import { useState } from "react";
import { useAuth } from "@/components/auth/AuthContext";
import Button from "@/components/ui/Button";
import { FaReply } from "react-icons/fa";

export default function CommentForm({
  postId,
  parentId = null,
  onCommentSubmitted,
  isReply = false,
}) {
  const { user } = useAuth();
  const [content, setContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!user) {
      window.location.href = "/auth/login";
      return;
    }

    if (!content.trim()) {
      setError("Comment cannot be empty");
      return;
    }

    if (!postId) {
      setError("Post ID is missing");
      console.error("CommentForm error: postId is required but not provided");
      return;
    }

    setIsSubmitting(true);
    setError("");

    try {
      // Prepare the request body
      const requestBody = {
        content: content.trim(),
        postId,
      };

      // Only include parentId if it has a value
      if (parentId) {
        requestBody.parentId = parentId;
      }

      const response = await fetch("/api/comments", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Failed to submit comment");
      }

      setContent("");

      if (onCommentSubmitted && data.comment) {
        onCommentSubmitted(data.comment);
      }
    } catch (err) {
      console.error("Comment submission error:", err);
      setError(err.message || "Failed to submit comment. Please try again.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="mb-3">
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder={
            isReply
              ? "What are your thoughts on this comment?"
              : "What are your thoughts?"
          }
          className="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          rows={isReply ? 3 : 4}
          disabled={isSubmitting}
        />
        {error && <p className="mt-1 text-red-500 text-sm">{error}</p>}
      </div>

      <div className="flex justify-end">
        <Button
          type="submit"
          variant={isReply ? "secondary" : "primary"}
          disabled={isSubmitting || !content.trim()}
          isLoading={isSubmitting}
          icon={isReply ? <FaReply /> : null}
        >
          {isReply ? "Reply" : "Comment"}
        </Button>
      </div>
    </form>
  );
}

================
File: src/components/comment/CommentItem.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useAuth } from "@/components/auth/AuthContext";
import { formatRelativeTime } from "@/lib/utils";
import CommentForm from "./CommentForm";
import { FaArrowUp, FaArrowDown, FaReply } from "react-icons/fa";
import Button from "@/components/ui/Button";

export default function CommentItem({
  comment,
  postId,
  groupName,
  onReplySubmitted,
  depth = 0,
}) {
  const { user } = useAuth();
  const [voteStatus, setVoteStatus] = useState(0);
  const [voteScore, setVoteScore] = useState(0);
  const [showReplyForm, setShowReplyForm] = useState(false);
  const [isExpanded, setIsExpanded] = useState(true);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Initialize with comment's vote count if available
    if (comment.score !== undefined) {
      setVoteScore(comment.score);
    } else {
      // Fetch the score
      fetchCommentScore();
    }

    // Only fetch vote status if user is logged in
    if (user) {
      fetchVoteStatus();
    }
  }, [comment.id, user]);

  // Function to fetch the comment's actual vote score
  const fetchCommentScore = async () => {
    try {
      const response = await fetch(`/api/votes/score?commentId=${comment.id}`);
      if (response.ok) {
        const data = await response.json();
        setVoteScore(data.score || 0);
      }
    } catch (error) {
      console.error("Error fetching comment score:", error);
    }
  };

  // Fetch the user's vote status
  const fetchVoteStatus = async () => {
    if (!user) return;

    try {
      setLoading(true);
      const response = await fetch(`/api/votes/status?commentId=${comment.id}`);

      if (response.ok) {
        const data = await response.json();
        if (data.vote) {
          setVoteStatus(data.vote.value);
        }
      }
    } catch (error) {
      console.error("Error fetching vote status:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleVote = async (value) => {
    if (!user) {
      // Redirect to login if not authenticated
      window.location.href = "/auth/login";
      return;
    }

    // If clicking the same vote button, remove the vote
    const newValue = voteStatus === value ? 0 : value;

    try {
      setLoading(true);

      // Optimistically update UI for better user experience
      const voteChange = newValue - voteStatus;
      setVoteStatus(newValue);
      setVoteScore((prevScore) => prevScore + voteChange);

      const response = await fetch("/api/votes", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          value: newValue,
          commentId: comment.id,
        }),
      });

      if (!response.ok) {
        // Revert the optimistic update if the API call fails
        setVoteStatus(voteStatus);
        setVoteScore((prevScore) => prevScore - voteChange);
        throw new Error("Failed to register vote");
      }

      // API call succeeded - no need to revert optimistic update
    } catch (error) {
      console.error("Vote error:", error);
    } finally {
      setLoading(false);
    }
  };

  const toggleReplyForm = () => {
    setShowReplyForm(!showReplyForm);
  };

  const toggleExpanded = () => {
    setIsExpanded(!isExpanded);
  };

  const handleReplySubmitted = (newReply) => {
    // Pass the comment's ID as the parentId
    if (onReplySubmitted) {
      onReplySubmitted(comment.id, newReply);
      setShowReplyForm(false);
    }
  };

  // Updated visual indicator for deeper nesting
  const getIndentColor = () => {
    const colors = [
      "border-gray-300",
      "border-blue-100",
      "border-green-100",
      "border-yellow-100",
      "border-purple-100",
      "border-pink-100",
      "border-indigo-100",
      "border-red-100",
    ];

    return colors[depth % colors.length];
  };

  return (
    <div className={`border-l-2 ${getIndentColor()} pl-3`}>
      <div className="flex items-start space-x-2">
        {/* Vote buttons */}
        <div className="flex flex-col items-center pt-1">
          <button
            onClick={() => handleVote(1)}
            className={`p-1 rounded-sm hover:bg-gray-200 ${
              voteStatus === 1 ? "text-orange-500" : "text-gray-500"
            }`}
            aria-label="Upvote"
            disabled={loading}
          >
            <FaArrowUp className="text-xs" />
          </button>

          <span
            className={`text-xs font-medium my-0.5 ${
              voteStatus === 1
                ? "text-orange-500"
                : voteStatus === -1
                ? "text-blue-500"
                : "text-gray-800"
            }`}
          >
            {voteScore}
          </span>

          <button
            onClick={() => handleVote(-1)}
            className={`p-1 rounded-sm hover:bg-gray-200 ${
              voteStatus === -1 ? "text-blue-500" : "text-gray-500"
            }`}
            aria-label="Downvote"
            disabled={loading}
          >
            <FaArrowDown className="text-xs" />
          </button>
        </div>

        {/* Comment content */}
        <div className="flex-grow">
          {/* Comment header */}
          <div className="flex items-center text-xs text-gray-500 mb-1">
            <Link
              href={`/user/${comment.author.username}`}
              className="font-medium text-gray-900 hover:underline"
            >
              {comment.author.username}
            </Link>
            <span className="mx-1">•</span>
            <span>{formatRelativeTime(comment.createdAt)}</span>
            {depth > 0 && (
              <span className="mx-1 text-xs text-gray-400">
                • Depth: {depth}
              </span>
            )}
            <button
              onClick={toggleExpanded}
              className="ml-2 text-gray-500 hover:text-gray-700"
            >
              [{isExpanded ? "−" : "+"}]
            </button>
          </div>

          {/* Comment body */}
          {isExpanded && (
            <>
              <div className="text-sm text-gray-800 mb-2">
                {comment.content}
              </div>

              {/* Comment actions */}
              <div className="flex items-center text-xs text-gray-500 mb-2">
                {user && (
                  <Button
                    onClick={toggleReplyForm}
                    variant="ghost"
                    size="sm"
                    icon={<FaReply />}
                  >
                    Reply
                  </Button>
                )}
              </div>

              {/* Reply form - note that the parentId is this comment's ID */}
              {showReplyForm && (
                <div className="my-2">
                  <CommentForm
                    postId={postId}
                    parentId={comment.id}
                    onCommentSubmitted={handleReplySubmitted}
                    isReply
                  />
                </div>
              )}

              {/* Nested replies - now with unlimited nesting */}
              {comment.replies && comment.replies.length > 0 && (
                <div className="mt-2 space-y-3">
                  {comment.replies.map((reply) => (
                    <CommentItem
                      key={reply.id}
                      comment={reply}
                      postId={postId}
                      groupName={groupName}
                      onReplySubmitted={onReplySubmitted}
                      depth={depth + 1}
                    />
                  ))}
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/components/comment/CommentSection.js
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/components/auth/AuthContext";
import CommentItem from "./CommentItem";
import CommentForm from "./CommentForm";
import { FaComment } from "react-icons/fa";
import Button from "@/components/ui/Button";

export default function CommentSection({ postId, groupName }) {
  const { user } = useAuth();
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchComments = async () => {
    if (!postId) return;

    try {
      setLoading(true);
      const response = await fetch(`/api/comments?postId=${postId}`);

      if (!response.ok) {
        throw new Error("Failed to fetch comments");
      }

      const data = await response.json();
      setComments(data.comments);
    } catch (err) {
      console.error("Error fetching comments:", err);
      setError("Failed to load comments. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchComments();
  }, [postId]);

  // Handle a new top-level comment
  const handleNewComment = (newComment) => {
    // Add new comment to the top of the list
    setComments((prev) => [
      {
        ...newComment,
        replies: [],
        _count: { replies: 0 },
      },
      ...prev,
    ]);
  };

  // This function recursively updates the comment tree to add a reply
  // to the correct parent comment
  const updateRepliesRecursively = (comments, targetParentId, newReply) => {
    return comments.map((comment) => {
      // If this is the target parent comment, add the reply to it
      if (comment.id === targetParentId) {
        return {
          ...comment,
          replies: [
            ...(comment.replies || []),
            { ...newReply, replies: [], _count: { replies: 0 } },
          ],
          _count: {
            ...comment._count,
            replies: (comment._count?.replies || 0) + 1,
          },
        };
      }

      // If this comment has replies, recursively check them
      if (comment.replies && comment.replies.length > 0) {
        const updatedReplies = updateRepliesRecursively(
          comment.replies,
          targetParentId,
          newReply
        );

        // Only update this comment if one of its replies changed
        if (
          JSON.stringify(updatedReplies) !== JSON.stringify(comment.replies)
        ) {
          return {
            ...comment,
            replies: updatedReplies,
          };
        }
      }

      // Return unchanged if not the target and no child replies were changed
      return comment;
    });
  };

  // Handle a reply to any comment (top-level or nested)
  const handleReply = (parentId, newReply) => {
    setComments((prevComments) =>
      updateRepliesRecursively(prevComments, parentId, newReply)
    );
  };

  return (
    <div className="bg-white rounded-md shadow-sm p-4">
      <h2 className="text-lg font-semibold mb-4 flex items-center">
        <FaComment className="mr-2 text-gray-600" />
        Comments
      </h2>

      {user && (
        <div className="mb-6">
          <CommentForm postId={postId} onCommentSubmitted={handleNewComment} />
        </div>
      )}

      {loading ? (
        <div className="flex justify-center py-8">
          <Button isLoading>Loading comments</Button>
        </div>
      ) : error ? (
        <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>
      ) : comments.length === 0 ? (
        <div className="text-center py-8 text-gray-500">
          <p>No comments yet. Be the first to share your thoughts!</p>
          {!user && (
            <p className="mt-2 text-sm">
              <Button href="/auth/login" variant="link">
                Log in
              </Button>{" "}
              to leave a comment.
            </p>
          )}
        </div>
      ) : (
        <div className="space-y-4">
          {comments.map((comment) => (
            <CommentItem
              key={comment.id}
              comment={comment}
              postId={postId}
              groupName={groupName}
              onReplySubmitted={handleReply}
              depth={0}
            />
          ))}
        </div>
      )}
    </div>
  );
}

================
File: src/components/group/GroupAbout.js
================
import Link from "next/link";
import { formatDate } from "@/lib/utils";
import Button from "@/components/ui/Button";
import { FaPlus } from "react-icons/fa";

export default function GroupAbout({ group }) {
  // Check if group._count exists before trying to access its properties
  const memberCount = group?._count?.members || 0;
  const postCount = group?._count?.posts || 0;

  return (
    <div className="bg-white rounded-md shadow-sm p-4">
      <h2 className="text-lg font-semibold mb-3">About Group</h2>

      {group.description && (
        <p className="text-sm text-gray-700 mb-4">{group.description}</p>
      )}

      <div className="border-t border-gray-200 pt-3 mt-3">
        <div className="flex justify-between mb-3">
          <div>
            <p className="text-sm font-semibold">{memberCount}</p>
            <p className="text-xs text-gray-500">Members</p>
          </div>
          <div>
            <p className="text-sm font-semibold">{postCount}</p>
            <p className="text-xs text-gray-500">Posts</p>
          </div>
          <div>
            <p className="text-sm font-semibold">1</p>
            <p className="text-xs text-gray-500">Online</p>
          </div>
        </div>
      </div>

      <div className="border-t border-gray-200 pt-3 mt-3">
        <p className="text-xs text-gray-500">
          Created {formatDate(group.createdAt)}
        </p>
      </div>

      <div className="mt-4">
        <Button
          href={`/create/post`}
          fullWidth
          variant="primary"
          icon={<FaPlus />}
        >
          Create Post
        </Button>
      </div>
    </div>
  );
}

================
File: src/components/group/GroupHeader.js
================
"use client";

import { useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { useAuth } from "@/components/auth/AuthContext";
import { generateGroupColor } from "@/lib/utils";
import Button from "@/components/ui/Button";

export default function GroupHeader({ group }) {
  const { user } = useAuth();
  const [isJoined, setIsJoined] = useState(false);
  const [memberCount, setMemberCount] = useState(group._count.members);
  const [isLoading, setIsLoading] = useState(false);

  const handleJoinGroup = async () => {
    if (!user) {
      window.location.href = "/auth/login";
      return;
    }

    // Check if the current user is the owner of the group
    if (group.owner.username === user.username) {
      return;
    }

    setIsLoading(true);

    try {
      const action = isJoined ? "leave" : "join";
      const response = await fetch(`/api/groups/${group.id}/${action}`, {
        method: "POST",
      });

      if (!response.ok) {
        throw new Error(`Failed to ${action} group`);
      }

      setIsJoined(!isJoined);
      setMemberCount((prevCount) => (isJoined ? prevCount - 1 : prevCount + 1));
    } catch (error) {
      console.error("Join/leave error:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      {/* Banner */}
      <div
        className={`h-20 ${generateGroupColor(group.name)} rounded-t-md`}
      ></div>

      {/* Group info */}
      <div className="bg-white shadow-sm px-4 pb-3">
        <div className="flex items-start">
          {/* Group icon */}
          <div
            className={`-mt-4 w-16 h-16 rounded-full border-4 border-white ${generateGroupColor(
              group.name
            )} flex items-center justify-center`}
          >
            {/* Replace FaReddit with your custom logo icon */}
            <Image
              src="/logo-icon.png"
              alt="Group"
              width={32}
              height={32}
              className="text-white text-3xl"
            />
          </div>

          <div className="ml-4 pt-2 flex-grow">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-2xl font-bold">{group.name}</h1>
                <p className="text-sm text-gray-500">
                  {memberCount} {memberCount === 1 ? "member" : "members"} •
                  Created by{" "}
                  <Link
                    href={`/${group.owner.username}`}
                    className="hover:underline"
                  >
                    {group.owner.username}
                  </Link>
                </p>
              </div>

              <Button
                onClick={handleJoinGroup}
                variant={isJoined ? "outlined" : "primary"}
                isLoading={isLoading}
              >
                {isJoined ? "Joined" : "Join"}
              </Button>
            </div>
          </div>
        </div>

        {/* Navigation tabs */}
        <div className="flex space-x-4 mt-4 border-b border-gray-200">
          <Link
            href={`/group/${group.name}`}
            className="px-3 py-2 text-gray-800 border-b-2 border-blue-500 font-medium"
          >
            Posts
          </Link>
          <button className="px-3 py-2 text-gray-500 hover:bg-gray-100 rounded-t-md">
            About
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/group/GroupSidebar.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { FaSpinner } from "react-icons/fa";
import { generateGroupColor } from "@/lib/utils";

export default function GroupSidebar() {
  const [groups, setGroups] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchGroups = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/groups");

        if (!response.ok) {
          throw new Error("Failed to fetch groups");
        }

        const data = await response.json();
        setGroups(data.groups.slice(0, 5)); // Show top 5 groups
      } catch (err) {
        console.error("Error fetching groups:", err);
        setError("Failed to load groups");
      } finally {
        setLoading(false);
      }
    };

    fetchGroups();
  }, []);

  if (loading) {
    return (
      <div className="bg-white rounded-md shadow-sm p-4">
        <h2 className="text-lg font-semibold mb-3">Top Groups</h2>
        <div className="flex justify-center py-8">
          <FaSpinner className="text-gray-400 animate-spin text-xl" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-md shadow-sm p-4">
        <h2 className="text-lg font-semibold mb-3">Top Groups</h2>
        <p className="text-red-500 text-sm">{error}</p>
      </div>
    );
  }

  if (groups.length === 0) {
    return (
      <div className="bg-white rounded-md shadow-sm p-4">
        <h2 className="text-lg font-semibold mb-3">Top Groups</h2>
        <p className="text-gray-500 text-sm mb-4">No groups found.</p>
        <Link
          href="/create/group"
          className="block w-full bg-blue-500 text-white text-center py-2 px-4 rounded-md hover:bg-blue-600"
        >
          Create Group
        </Link>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-md shadow-sm p-4">
      <h2 className="text-lg font-semibold mb-3">Top Groups</h2>
      <ul className="space-y-3">
        {groups.map((group) => (
          <li key={group.id}>
            <Link
              href={`/group/${group.name}`}
              className="flex items-center p-2 hover:bg-gray-100 rounded-md"
            >
              <div
                className={`w-8 h-8 rounded-full ${generateGroupColor(
                  group.name
                )} flex items-center justify-center mr-2`}
              >
                <Image
                  src="/logo-icon.png"
                  alt="Group"
                  width={16}
                  height={16}
                  className="text-white"
                />
              </div>
              <div className="flex-grow">
                <p className="font-medium">{group.name}</p>
                <p className="text-xs text-gray-500">
                  {group._count.members}{" "}
                  {group._count.members === 1 ? "member" : "members"}
                </p>
              </div>
            </Link>
          </li>
        ))}
      </ul>
      <div className="mt-4 pt-3 border-t border-gray-200">
        <Link href="/groups" className="text-blue-500 text-sm hover:underline">
          View All Groups
        </Link>
      </div>
    </div>
  );
}

================
File: src/components/layout/Header.js
================
"use client";

import { useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/auth/AuthContext";
import { FaSearch, FaUser, FaBars } from "react-icons/fa";
import Button from "@/components/ui/Button";

export default function Header() {
  const { user, logout } = useAuth();
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState("");
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  const handleSearch = (e) => {
    e.preventDefault();
    if (searchQuery.trim()) {
      router.push(`/search?q=${encodeURIComponent(searchQuery.trim())}`);
    }
  };
  const toggleMenu = () => {
    setIsMenuOpen(!isMenuOpen);
  };

  return (
    <header className="bg-background-rgb shadow-sm">
      <div className="container mx-auto px-4 py-2 border-b">
        <div className="flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center space-x-2">
            <Image
              src="/logo.png"
              alt="CardiNet Logo"
              width={64}
              height={64}
              className="text-3xl"
            />
            <span className="text-2xl font-bold hidden sm:inline text-yellow-400">
              CardiNet
            </span>
          </Link>

          {/* Search Bar */}
          <form onSubmit={handleSearch} className="flex-grow max-w-xl mx-4">
            <div className="relative">
              <input
                type="text"
                placeholder="Search"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full py-1 px-3 pl-10 border border-gray-300 rounded-full bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white"
              />
              <FaSearch className="absolute left-3 top-2 text-gray-400" />
            </div>
          </form>

          {/* Mobile Menu Button */}
          <button
            className="sm:hidden text-gray-700 focus:outline-none"
            onClick={toggleMenu}
          >
            <FaBars size={24} />
          </button>

          {/* Desktop Navigation */}
          <div className="hidden sm:flex items-center space-x-4">
            {user ? (
              <>
                <div className="relative group">
                  <button className="flex items-center space-x-1 text-white hover:text-yellow-400">
                    <FaUser />
                    <span>{user.username}</span>
                  </button>
                  {/* Modified dropdown to reduce gap and add connecting area */}
                  <div className="absolute right-0 mt-0 pt-2 w-48 z-10 hidden group-hover:block">
                    {/* This invisible element helps connect the button to the dropdown */}
                    <div className="h-2"></div>
                    <div className="bg-white rounded-md shadow-lg py-1">
                      <Link
                        href={`/user/${user.username}`}
                        className="block px-4 py-2 text-gray-700 hover:bg-gray-100"
                      >
                        Profile
                      </Link>
                      <Link
                        href="/create/group"
                        className="block px-4 py-2 text-gray-700 hover:bg-gray-100"
                      >
                        Create Group
                      </Link>
                      <button
                        onClick={logout}
                        className="block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100"
                      >
                        Logout
                      </button>
                    </div>
                  </div>
                </div>
              </>
            ) : (
              <div className="flex space-x-2">
                <Button href="/auth/login" variant="outlined">
                  Log In
                </Button>
                <Button href="/auth/register" variant="primary">
                  Sign Up
                </Button>
              </div>
            )}
          </div>
        </div>

        {/* Mobile Menu */}
        {isMenuOpen && (
          <div className="sm:hidden mt-2 py-2 border-t">
            {user ? (
              <div className="space-y-2">
                <Link
                  href={`/${user.username}`}
                  className="block px-2 py-1 text-gray-700"
                >
                  Profile
                </Link>
                <Link
                  href="/create/post"
                  className="block px-2 py-1 text-gray-700"
                >
                  Create Post
                </Link>
                <Link
                  href="/create/group"
                  className="block px-2 py-1 text-gray-700"
                >
                  Create Group
                </Link>
                <button
                  onClick={logout}
                  className="block w-full text-left px-2 py-1 text-gray-700"
                >
                  Logout
                </button>
              </div>
            ) : (
              <div className="space-y-2">
                <Link
                  href="/auth/login"
                  className="block px-2 py-1 text-gray-700"
                >
                  Log In
                </Link>
                <Link
                  href="/auth/register"
                  className="block px-2 py-1 text-gray-700"
                >
                  Sign Up
                </Link>
              </div>
            )}
          </div>
        )}
      </div>
    </header>
  );
}

================
File: src/components/layout/LeftSidebar.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { usePathname } from "next/navigation";
import {
  FaHome,
  FaFire,
  FaCompass,
  FaUserFriends,
  FaChevronDown,
  FaChevronUp,
} from "react-icons/fa";
import { generateGroupColor } from "@/lib/utils";

export default function LeftSidebar() {
  const [groups, setGroups] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isGroupsExpanded, setIsGroupsExpanded] = useState(true);
  const pathname = usePathname();

  useEffect(() => {
    const fetchGroups = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/groups");

        if (!response.ok) {
          throw new Error("Failed to fetch groups");
        }

        const data = await response.json();
        setGroups(data.groups);
      } catch (err) {
        console.error("Error fetching groups:", err);
        setError("Failed to load groups");
      } finally {
        setLoading(false);
      }
    };

    fetchGroups();
  }, []);

  const toggleGroupsExpanded = () => {
    setIsGroupsExpanded(!isGroupsExpanded);
  };

  const isActive = (path) => {
    return pathname === path;
  };

  return (
    <div className="hidden md:block w-64 p-4 h-fit sticky top-4 text-white">
      <div className="space-y-4">
        {/* Main navigation */}
        <div className="space-y-1">
          <Link
            href="/"
            className={`group flex items-center px-4 py-2 rounded-md transition ${
              isActive("/")
                ? "bg-yellow-500 text-black font-medium"
                : "hover:bg-yellow-500 hover:text-black"
            }`}
          >
            <FaHome
              className={`mr-3 transition ${
                isActive("/")
                  ? "text-black"
                  : "text-white group-hover:text-black"
              }`}
            />
            <span>Home</span>
          </Link>

          <Link
            href="/popular"
            className={`group flex items-center px-4 py-2 rounded-md transition ${
              isActive("/popular")
                ? "bg-yellow-500 text-black font-medium"
                : "hover:bg-yellow-500 hover:text-black"
            }`}
          >
            <FaFire
              className={`mr-3 transition ${
                isActive("/popular")
                  ? "text-black"
                  : "text-white group-hover:text-black"
              }`}
            />
            <span>Popular</span>
          </Link>

          <Link
            href="/explore"
            className={`group flex items-center px-4 py-2 rounded-md transition ${
              isActive("/explore")
                ? "bg-yellow-500 text-black font-medium"
                : "hover:bg-yellow-500 hover:text-black"
            }`}
          >
            <FaCompass
              className={`mr-3 transition ${
                isActive("/explore")
                  ? "text-black"
                  : "text-white group-hover:text-black"
              }`}
            />
            <span>Explore</span>
          </Link>

          <Link
            href="/friends"
            className={`group flex items-center px-4 py-2 rounded-md transition ${
              isActive("/friends")
                ? "bg-yellow-500 text-black font-medium"
                : "hover:bg-yellow-500 hover:text-black"
            }`}
          >
            <FaUserFriends
              className={`mr-3 transition ${
                isActive("/friends")
                  ? "text-black"
                  : "text-white group-hover:text-black"
              }`}
            />
            <span>Friends</span>
          </Link>
        </div>

        {/* Groups dropdown */}
        <div>
          <button
            onClick={toggleGroupsExpanded}
            className="flex items-center justify-between w-full px-4 py-2 text-left font-medium border-t border-b border-white"
          >
            <span>Groups</span>
            {isGroupsExpanded ? (
              <FaChevronUp className="text-white" />
            ) : (
              <FaChevronDown className="text-white" />
            )}
          </button>

          {isGroupsExpanded && (
            <div className="mt-2 space-y-1 max-h-64 overflow-y-auto">
              {loading ? (
                <div className="px-4 py-2 text-gray-300 text-sm">
                  Loading...
                </div>
              ) : error ? (
                <div className="px-4 py-2 text-red-300 text-sm">{error}</div>
              ) : groups.length === 0 ? (
                <div className="px-4 py-2 text-gray-300 text-sm">
                  No groups found
                </div>
              ) : (
                groups.map((group) => (
                  <Link
                    key={group.id}
                    href={`/group/${group.name}`}
                    className="flex items-center px-4 py-2 hover:bg-gray-800 hover:bg-opacity-20 rounded-md"
                  >
                    <div
                      className={`w-6 h-6 rounded-full ${generateGroupColor(
                        group.name
                      )} flex items-center justify-center mr-2`}
                    >
                      <Image
                        src="/logo-icon.png"
                        alt="Group"
                        width={12}
                        height={12}
                        className="text-white text-xs"
                      />
                    </div>
                    <span className="truncate">{group.name}</span>
                  </Link>
                ))
              )}
              <Link
                href="/create/group"
                className="flex items-center px-4 py-2 text-yellow-400 hover:bg-gray-800 hover:bg-opacity-20 rounded-md"
              >
                <span>+ Create Group</span>
              </Link>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/components/post/FriendsPosts.js
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import PostItem from "@/components/post/PostItem";
import { useAuth } from "@/components/auth/AuthContext";
import { FaSpinner, FaUserFriends, FaPlus } from "react-icons/fa";

export default function FriendsPosts() {
  const { user, isAuthenticated } = useAuth();
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 10,
    totalPages: 0,
  });
  const [friends, setFriends] = useState([]);
  const [loadingFriends, setLoadingFriends] = useState(true);

  const fetchFriends = async () => {
    if (!isAuthenticated) {
      setLoadingFriends(false);
      return;
    }

    try {
      const response = await fetch(`/api/users/${user.username}`);
      if (!response.ok) {
        throw new Error("Failed to fetch user data");
      }

      const userData = await response.json();
      setFriends(userData.friends || []);
    } catch (err) {
      console.error("Error fetching friends:", err);
    } finally {
      setLoadingFriends(false);
    }
  };

  const fetchPosts = async (resetPage = false) => {
    if (!isAuthenticated) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      const page = resetPage ? 1 : pagination.page;

      const queryParams = new URLSearchParams({
        page,
        limit: pagination.limit,
      });

      const response = await fetch(`/api/posts/friends?${queryParams}`);

      if (!response.ok) {
        throw new Error("Failed to fetch friends' posts");
      }

      const data = await response.json();

      if (resetPage) {
        setPosts(data.posts);
      } else {
        setPosts((prev) => [...prev, ...data.posts]);
      }

      setPagination((prev) => ({
        ...prev,
        page: page,
        totalPages: data.pagination.totalPages,
      }));
    } catch (err) {
      console.error("Error fetching friends' posts:", err);
      setError(
        "Failed to load posts from your friends. Please try again later."
      );
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchFriends();
    fetchPosts(true);
  }, [isAuthenticated, user]);

  const handleLoadMore = () => {
    if (pagination.page < pagination.totalPages) {
      setPagination((prev) => ({
        ...prev,
        page: prev.page + 1,
      }));
      fetchPosts(false);
    }
  };

  if (!isAuthenticated) {
    return (
      <div className="bg-white rounded-md shadow-sm p-6 text-center">
        <FaUserFriends className="mx-auto text-4xl text-gray-400 mb-4" />
        <h1 className="text-2xl font-bold mb-2">Friends Feed</h1>
        <p className="text-gray-600 mb-4">
          You need to be logged in to view posts from your friends.
        </p>
        <Link
          href="/auth/login"
          className="bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600"
        >
          Log In
        </Link>
      </div>
    );
  }

  return (
    <div>
      {/* Header */}
      <div className="bg-white rounded-md shadow-sm p-4 mb-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-xl font-bold flex items-center">
              <FaUserFriends className="text-blue-500 mr-2" />
              Friends Feed
            </h1>
            <p className="text-sm text-gray-600 mt-1">
              See the latest posts from your friends
            </p>
          </div>
          <Link
            href="/explore"
            className="text-sm text-blue-500 hover:underline flex items-center"
          >
            <FaPlus className="mr-1" /> Find more people
          </Link>
        </div>
      </div>

      {/* Friend List Preview */}
      {!loadingFriends && (
        <div className="bg-white rounded-md shadow-sm p-4 mb-4">
          <div className="flex items-center justify-between mb-3">
            <h2 className="font-medium">Your Friends ({friends.length})</h2>
            {friends.length > 0 && (
              <Link
                href="/user"
                className="text-sm text-blue-500 hover:underline"
              >
                View All
              </Link>
            )}
          </div>

          {friends.length === 0 ? (
            <div className="text-center py-2">
              <p className="text-gray-500 text-sm">
                You haven't added any friends yet.
              </p>
              <p className="text-xs text-gray-500 mt-1">
                Find users and click "Add Friend" to see their posts here.
              </p>
            </div>
          ) : (
            <div className="flex flex-wrap gap-2">
              {friends.slice(0, 5).map((friend) => (
                <Link
                  key={friend.id}
                  href={`/user/${friend.username}`}
                  className="flex items-center bg-gray-100 py-1 px-2 rounded-full hover:bg-gray-200"
                >
                  <div className="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center text-white text-xs font-bold mr-1">
                    {friend.username.slice(0, 1).toUpperCase()}
                  </div>
                  <span className="text-sm">{friend.username}</span>
                </Link>
              ))}
              {friends.length > 5 && (
                <Link
                  href="/user"
                  className="flex items-center bg-gray-100 py-1 px-3 rounded-full hover:bg-gray-200"
                >
                  <span className="text-sm">+{friends.length - 5} more</span>
                </Link>
              )}
            </div>
          )}
        </div>
      )}

      {/* Posts Section */}
      {loading && posts.length === 0 ? (
        <div className="flex justify-center items-center py-12">
          <FaSpinner className="text-2xl text-gray-500 animate-spin" />
        </div>
      ) : error ? (
        <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>
      ) : posts.length === 0 ? (
        <div className="bg-white rounded-md shadow-sm p-6 text-center">
          <h2 className="text-lg font-semibold mb-2">
            No posts from friends yet
          </h2>
          <p className="text-gray-600 mb-4">
            {friends.length === 0
              ? "Add some friends to see their posts here."
              : "Your friends haven't created any posts yet."}
          </p>
          <Link
            href="/explore"
            className="inline-block bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600"
          >
            Explore Groups
          </Link>
        </div>
      ) : (
        <div className="space-y-4">
          {posts.map((post) => (
            <PostItem key={post.id} post={post} />
          ))}

          {pagination.page < pagination.totalPages && (
            <div className="flex justify-center py-4">
              <button
                onClick={handleLoadMore}
                className="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-6 rounded-md"
              >
                {loading ? (
                  <span className="flex items-center">
                    <FaSpinner className="animate-spin mr-2" /> Loading...
                  </span>
                ) : (
                  "Load More"
                )}
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: src/components/post/PopularPosts.js
================
"use client";

import { useState, useEffect } from "react";
import PostItem from "@/components/post/PostItem";
import { FaSpinner, FaFireAlt } from "react-icons/fa";

export default function PopularPosts() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedPeriod, setSelectedPeriod] = useState("week");
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 10,
    totalPages: 0,
  });

  const fetchPosts = async (resetPage = false) => {
    try {
      setLoading(true);
      const page = resetPage ? 1 : pagination.page;

      const queryParams = new URLSearchParams({
        page,
        limit: pagination.limit,
        period: selectedPeriod,
      });

      const response = await fetch(`/api/posts/popular?${queryParams}`);

      if (!response.ok) {
        throw new Error("Failed to fetch popular posts");
      }

      const data = await response.json();

      if (resetPage) {
        setPosts(data.posts);
      } else {
        setPosts((prev) => [...prev, ...data.posts]);
      }

      setPagination((prev) => ({
        ...prev,
        page: page,
        totalPages: data.pagination.totalPages,
      }));
    } catch (err) {
      console.error("Error fetching popular posts:", err);
      setError("Failed to load popular posts. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPosts(true);
  }, [selectedPeriod]);

  const handleLoadMore = () => {
    if (pagination.page < pagination.totalPages) {
      setPagination((prev) => ({
        ...prev,
        page: prev.page + 1,
      }));
      fetchPosts(false);
    }
  };

  const handlePeriodChange = (period) => {
    setSelectedPeriod(period);
  };

  if (loading && posts.length === 0) {
    return (
      <div className="flex justify-center items-center py-12">
        <FaSpinner className="text-2xl text-gray-500 animate-spin" />
      </div>
    );
  }

  if (error) {
    return <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>;
  }

  return (
    <div>
      {/* Filter Controls */}
      <div className="bg-white rounded-md shadow-sm p-4 mb-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <FaFireAlt className="text-orange-500 mr-2" />
            <h2 className="text-lg font-semibold">Popular Posts</h2>
          </div>
          <div className="flex space-x-2 text-sm">
            <button
              onClick={() => handlePeriodChange("day")}
              className={`px-3 py-1 rounded-full ${
                selectedPeriod === "day"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 hover:bg-gray-300"
              }`}
            >
              Today
            </button>
            <button
              onClick={() => handlePeriodChange("week")}
              className={`px-3 py-1 rounded-full ${
                selectedPeriod === "week"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 hover:bg-gray-300"
              }`}
            >
              This Week
            </button>
            <button
              onClick={() => handlePeriodChange("month")}
              className={`px-3 py-1 rounded-full ${
                selectedPeriod === "month"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 hover:bg-gray-300"
              }`}
            >
              This Month
            </button>
            <button
              onClick={() => handlePeriodChange("all")}
              className={`px-3 py-1 rounded-full ${
                selectedPeriod === "all"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 hover:bg-gray-300"
              }`}
            >
              All Time
            </button>
          </div>
        </div>
      </div>

      {/* Posts List */}
      {posts.length === 0 ? (
        <div className="bg-white rounded-md shadow-sm p-6 text-center">
          <h2 className="text-lg font-semibold mb-2">No popular posts</h2>
          <p className="text-gray-600">
            There are no popular posts for the selected time period.
          </p>
        </div>
      ) : (
        <div className="space-y-4">
          {posts.map((post) => (
            <PostItem key={post.id} post={post} />
          ))}

          {pagination.page < pagination.totalPages && (
            <div className="flex justify-center py-4">
              <button
                onClick={handleLoadMore}
                className="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-6 rounded-md"
              >
                {loading ? (
                  <span className="flex items-center">
                    <FaSpinner className="animate-spin mr-2" /> Loading...
                  </span>
                ) : (
                  "Load More"
                )}
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: src/components/post/PostItem.js
================
"use client";

import Link from "next/link";
import Image from "next/image";
import { useState, useEffect } from "react";
import { useAuth } from "@/components/auth/AuthContext";
import { formatRelativeTime } from "@/lib/utils";
import { FaArrowUp, FaArrowDown, FaComments, FaShare } from "react-icons/fa";

export default function PostItem({ post, isDetailView = false }) {
  const { user } = useAuth();
  const [voteStatus, setVoteStatus] = useState(0); // -1 for downvote, 0 for no vote, 1 for upvote
  const [voteScore, setVoteScore] = useState(0); // Actual score (upvotes - downvotes)
  const [loading, setLoading] = useState(false);

  // Calculate initial vote score and fetch user's vote status
  useEffect(() => {
    // Initialize with post's vote count if available
    if (post.score !== undefined) {
      // If the API returns a pre-calculated score
      setVoteScore(post.score);
    } else if (post._count && post._count.votes !== undefined) {
      // We'll still need to get the actual vote score from the API
      fetchPostScore();
    }

    // Only fetch vote status if user is logged in
    if (user) {
      fetchVoteStatus();
    }
  }, [post.id, user]);

  // Function to fetch the post's actual vote score
  const fetchPostScore = async () => {
    try {
      const response = await fetch(`/api/votes/score?postId=${post.id}`);
      if (response.ok) {
        const data = await response.json();
        setVoteScore(data.score || 0);
      }
    } catch (error) {
      console.error("Error fetching post score:", error);
    }
  };

  // Fetch the user's vote status
  const fetchVoteStatus = async () => {
    if (!user) return; // Only fetch if user is logged in

    try {
      setLoading(true);
      const response = await fetch(`/api/votes/status?postId=${post.id}`);

      if (response.ok) {
        const data = await response.json();
        if (data.vote) {
          setVoteStatus(data.vote.value);
        }
      }
    } catch (error) {
      console.error("Error fetching vote status:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleVote = async (value) => {
    if (!user) {
      // Redirect to login if not authenticated
      window.location.href = "/auth/login";
      return;
    }

    // If clicking the same vote button, remove the vote
    const newValue = voteStatus === value ? 0 : value;

    try {
      setLoading(true);

      // Optimistically update UI for better user experience
      const voteChange = newValue - voteStatus;
      setVoteStatus(newValue);
      setVoteScore((prevScore) => prevScore + voteChange);

      const response = await fetch("/api/votes", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          value: newValue,
          postId: post.id,
        }),
      });

      if (!response.ok) {
        // Revert the optimistic update if the API call fails
        setVoteStatus(voteStatus);
        setVoteScore((prevScore) => prevScore - voteChange);
        throw new Error("Failed to register vote");
      }

      // API call succeeded - no need to revert optimistic update
    } catch (error) {
      console.error("Vote error:", error);
      // You could show a toast notification here
    } finally {
      setLoading(false);
    }
  };

  const groupLink = `/group/${post.group.name}`;
  const postLink = `${groupLink}/comments/${post.id}`;

  return (
    <div className="bg-white rounded-md shadow-sm hover:shadow-md transition-shadow">
      {/* Vote buttons (sidebar) */}
      <div className="flex">
        <div className="bg-gray-50 p-2 rounded-l-md flex flex-col items-center w-12">
          <button
            onClick={() => handleVote(1)}
            className={`p-1 rounded-sm hover:bg-gray-200 ${
              voteStatus === 1 ? "text-orange-500" : "text-gray-500"
            }`}
            aria-label="Upvote"
            disabled={loading}
          >
            <FaArrowUp />
          </button>

          <span
            className={`text-xs font-bold my-1 ${
              voteStatus === 1
                ? "text-orange-500"
                : voteStatus === -1
                ? "text-blue-500"
                : "text-gray-800"
            }`}
          >
            {voteScore}
          </span>

          <button
            onClick={() => handleVote(-1)}
            className={`p-1 rounded-sm hover:bg-gray-200 ${
              voteStatus === -1 ? "text-blue-500" : "text-gray-500"
            }`}
            aria-label="Downvote"
            disabled={loading}
          >
            <FaArrowDown />
          </button>
        </div>

        {/* Post content */}
        <div className="p-3 flex-grow">
          {/* Post header */}
          <div className="text-xs text-gray-500 mb-2">
            <Link
              href={groupLink}
              className="flex items-center text-xs hover:underline mr-1"
            >
              <div className="w-4 h-4 rounded-full bg-blue-500 flex items-center justify-center mr-1">
                {/* Replace FaReddit with your custom logo icon */}
                <Image
                  src="/logo-icon.png"
                  alt="Group"
                  width={10}
                  height={10}
                  className="text-white text-xs"
                />
              </div>
              <span className="font-medium hover:underline">
                {post.group.name}
              </span>
            </Link>
            <span className="text-gray-500">
              • Posted by{" "}
              <Link
                href={`/user/${post.author.username}`}
                className="hover:underline"
              >
                {post.author.username}
              </Link>{" "}
              {formatRelativeTime(post.createdAt)}
            </span>
          </div>

          {/* Post title */}
          <h2 className="text-lg font-medium mb-2">
            {isDetailView ? (
              post.title
            ) : (
              <Link href={postLink} className="hover:underline">
                {post.title}
              </Link>
            )}
          </h2>

          {/* Post content (optional - shown in detail view or if expanded) */}
          {(isDetailView || post.content) && (
            <div className="text-gray-800 mb-3 whitespace-pre-line">
              {post.content && post.content.length > 300 && !isDetailView ? (
                <>
                  {post.content.substring(0, 300)}...{" "}
                  <Link
                    href={postLink}
                    className="text-blue-500 hover:underline"
                  >
                    See More
                  </Link>
                </>
              ) : (
                post.content
              )}
            </div>
          )}

          {/* Post actions */}
          <div className="flex items-center text-gray-500 text-sm mt-2">
            <Link
              href={postLink}
              className="flex items-center mr-4 hover:bg-gray-100 p-1 rounded"
            >
              <FaComments className="mr-1" />
              <span>{post._count?.comments || 0} Comments</span>
            </Link>
          </div>
        </div>
      </div>
    </div>  );
}

================
File: src/components/post/PostList.js
================
"use client";

import { useState, useEffect } from "react";
import PostItem from "./PostItem";
import { FaSpinner } from "react-icons/fa";
import Button from "@/components/ui/Button";

export default function PostList({ groupId = null }) {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 10,
    totalPages: 0,
  });

  const fetchPosts = async () => {
    try {
      setLoading(true);
      const queryParams = new URLSearchParams({
        page: pagination.page,
        limit: pagination.limit,
      });

      if (groupId) {
        queryParams.append("groupId", groupId);
      }

      const response = await fetch(`/api/posts?${queryParams}`);

      if (!response.ok) {
        throw new Error("Failed to fetch posts");
      }

      const data = await response.json();
      setPosts(data.posts);
      setPagination((prev) => ({
        ...prev,
        totalPages: data.pagination.totalPages,
      }));
    } catch (err) {
      console.error("Error fetching posts:", err);
      setError("Failed to load posts. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPosts();
  }, [pagination.page, groupId]);

  const handleLoadMore = () => {
    if (pagination.page < pagination.totalPages) {
      setPagination((prev) => ({
        ...prev,
        page: prev.page + 1,
      }));
    }
  };

  if (loading && posts.length === 0) {
    return (
      <div className="flex justify-center items-center py-12">
        <FaSpinner className="text-2xl text-gray-500 animate-spin" />
      </div>
    );
  }

  if (error) {
    return <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>;
  }

  if (posts.length === 0) {
    return (
      <div className="bg-white rounded-md shadow-sm p-6 text-center">
        <h2 className="text-lg font-semibold mb-2">No posts yet</h2>
        <p className="text-gray-600 mb-4">
          Be the first to start a discussion in this group.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {posts.map((post) => (
        <PostItem key={post.id} post={post} />
      ))}

      {pagination.page < pagination.totalPages && (
        <div className="flex justify-center py-4">
          <Button
            variant="secondary"
            onClick={handleLoadMore}
            isLoading={loading}
          >
            Load More
          </Button>
        </div>
      )}
    </div>
  );
}

================
File: src/components/post/RecentPosts.js
================
"use client";

import { useState, useEffect } from "react";
import PostItem from "@/components/post/PostItem";
import { FaSpinner, FaCompass } from "react-icons/fa";

export default function RecentPosts() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 10,
    totalPages: 0,
  });

  const fetchRecentPosts = async (resetPage = false) => {
    try {
      setLoading(true);
      const page = resetPage ? 1 : pagination.page;

      const queryParams = new URLSearchParams({
        page,
        limit: pagination.limit,
      });

      const response = await fetch(`/api/posts/recent?${queryParams}`);

      if (!response.ok) {
        throw new Error("Failed to fetch recent posts");
      }

      const data = await response.json();

      if (resetPage) {
        setPosts(data.posts);
      } else {
        setPosts((prev) => [...prev, ...data.posts]);
      }

      setPagination((prev) => ({
        ...prev,
        page: page,
        totalPages: data.pagination.totalPages,
      }));
    } catch (err) {
      console.error("Error fetching recent posts:", err);
      setError("Failed to load recent posts. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchRecentPosts(true);
  }, []);

  const handleLoadMore = () => {
    if (pagination.page < pagination.totalPages) {
      setPagination((prev) => ({
        ...prev,
        page: prev.page + 1,
      }));
      fetchRecentPosts(false);
    }
  };

  if (loading && posts.length === 0) {
    return (
      <div className="flex justify-center items-center py-12">
        <FaSpinner className="text-2xl text-gray-500 animate-spin" />
      </div>
    );
  }

  if (error) {
    return <div className="bg-red-50 text-red-700 p-4 rounded-md">{error}</div>;
  }

  return (
    <div>
      {/* Header */}
      <div className="bg-white rounded-md shadow-sm p-4 mb-4">
        <div className="flex items-center">
          <FaCompass className="text-blue-500 text-xl mr-2" />
          <h2 className="text-lg font-semibold">Explore Recent Posts</h2>
        </div>
        <p className="text-gray-600 text-sm mt-1">
          Discover the latest posts from all groups
        </p>
      </div>

      {/* Posts List */}
      {posts.length === 0 ? (
        <div className="bg-white rounded-md shadow-sm p-6 text-center">
          <h2 className="text-lg font-semibold mb-2">No posts yet</h2>
          <p className="text-gray-600">
            Be the first to start a discussion in the group.
          </p>
        </div>
      ) : (
        <div className="space-y-4">
          {posts.map((post) => (
            <PostItem key={post.id} post={post} />
          ))}

          {pagination.page < pagination.totalPages && (
            <div className="flex justify-center py-4">
              <button
                onClick={handleLoadMore}
                className="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-6 rounded-md"
              >
                {loading ? (
                  <span className="flex items-center">
                    <FaSpinner className="animate-spin mr-2" /> Loading...
                  </span>
                ) : (
                  "Load More"
                )}
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: src/components/ui/Button.js
================
"use client";

import { forwardRef } from "react";
import Link from "next/link";
import { FaSpinner } from "react-icons/fa";

const Button = forwardRef(
  (
    {
      children,
      variant = "primary",
      size = "md",
      href,
      isLoading = false,
      disabled = false,
      fullWidth = false,
      icon,
      iconPosition = "left",
      className = "",
      onClick,
      type = "button",
      ...props
    },
    ref
  ) => {
    // Define variant styles
    const variantStyles = {
      primary:
        "bg-yellow-500 text-black hover:bg-yellow-400 hover:text-black hover:shadow-sm",
      secondary: "bg-gray-200 text-gray-800 hover:bg-gray-300",
      outlined:
        "border border-yellow-500 text-yellow-500 hover:bg-yellow-300 hover:text-black",
      danger: "bg-red-500 text-white hover:bg-red-600",
      success: "bg-green-500 text-white hover:bg-green-600",
      ghost: "text-gray-700 hover:bg-gray-100",
      link: "text-blue-500 hover:underline p-0",
    };

    // Define size styles
    const sizeStyles = {
      sm: "text-xs px-3 py-1",
      md: "text-sm px-4 py-2",
      lg: "text-base px-6 py-3",
      xl: "text-lg px-8 py-4",
    };

    // Handle rounded styles
    const roundedStyles = {
      sm: "rounded",
      md: "rounded-md",
      lg: "rounded-lg",
      full: "rounded-full",
    };

    const rounded = variant === "link" ? "" : roundedStyles.full;

    // Compute the final className
    const buttonClasses = `
      ${variant !== "link" ? sizeStyles[size] : ""}
      ${variantStyles[variant]}
      ${rounded}
      ${fullWidth ? "w-full" : ""}
      ${disabled || isLoading ? "opacity-50 cursor-not-allowed" : ""}
      ${
        variant !== "link"
          ? "transition-colors focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2"
          : ""
      }
      ${className}
      ${
        icon && children
          ? iconPosition === "left"
            ? "flex items-center"
            : "flex flex-row-reverse items-center"
          : ""
      }
    `;

    // Render icon with proper spacing
    const renderIcon = () => {
      if (!icon) return null;

      return (
        <span
          className={`${
            children ? (iconPosition === "left" ? "mr-2" : "ml-2") : ""
          }`}
        >
          {icon}
        </span>
      );
    };

    // Render loading spinner
    const renderContent = () => {
      if (isLoading) {
        return (
          <span className="flex items-center justify-center">
            <FaSpinner className="animate-spin mr-2" />
            {children || "Loading..."}
          </span>
        );
      }

      if (icon && !children) {
        return renderIcon();
      }

      if (icon && children) {
        return (
          <>
            {iconPosition === "left" && renderIcon()}
            <span>{children}</span>
            {iconPosition === "right" && renderIcon()}
          </>
        );
      }

      return children;
    };

    // If href is provided, render as a Link component
    if (href && !disabled) {
      return (
        <Link href={href} className={buttonClasses} ref={ref} {...props}>
          {renderContent()}
        </Link>
      );
    }

    // Otherwise render as a button
    return (
      <button
        type={type}
        className={buttonClasses}
        disabled={disabled || isLoading}
        onClick={onClick}
        ref={ref}
        {...props}
      >
        {renderContent()}
      </button>
    );
  }
);

Button.displayName = "Button";

export default Button;

================
File: src/lib/auth.js
================
import { hash, compare } from "bcryptjs";
import prisma from "./db";

export async function createUser({ username, email, password }) {
  // Check if username or email already exists
  const existingUser = await prisma.user.findFirst({
    where: {
      OR: [{ username }, { email }],
    },
  });

  if (existingUser) {
    if (existingUser.username === username) {
      throw new Error("Username already exists");
    }
    if (existingUser.email === email) {
      throw new Error("Email already exists");
    }
  }

  // Hash the password
  const passwordHash = await hash(password, 12);

  // Create the user
  const user = await prisma.user.create({
    data: {
      username,
      email,
      passwordHash,
    },
  });

  return { id: user.id, username: user.username };
}

export async function verifyCredentials(usernameOrEmail, password) {
  // Find the user by username or email
  const user = await prisma.user.findFirst({
    where: {
      OR: [{ username: usernameOrEmail }, { email: usernameOrEmail }],
    },
  });

  if (!user) {
    return { success: false, error: "auth/user-not-found" };
  }

  // Verify the password
  const isValid = await compare(password, user.passwordHash);

  if (!isValid) {
    return { success: false, error: "auth/invalid-password" };
  }

  return {
    success: true,
    user: { id: user.id, username: user.username },
  };
}

export async function getUserById(id) {
  const user = await prisma.user.findUnique({
    where: { id },
    select: {
      id: true,
      username: true,
      email: true,
      createdAt: true,
      posts: {
        select: {
          id: true,
          title: true,
          createdAt: true,
          _count: {
            select: {
              comments: true,
              votes: true,
            },
          },
        },
        orderBy: {
          createdAt: "desc",
        },
        take: 10,
      },
    },
  });

  return user;
}

export async function getUserByUsername(username) {
  const user = await prisma.user.findUnique({
    where: { username },
    select: {
      id: true,
      username: true,
      createdAt: true,
      posts: {
        select: {
          id: true,
          title: true,
          createdAt: true,
          group: {
            select: {
              name: true,
            },
          },
          _count: {
            select: {
              comments: true,
              votes: true,
            },
          },
        },
        orderBy: {
          createdAt: "desc",
        },
      },
      comments: {
        select: {
          id: true,
          content: true,
          createdAt: true,
          post: {
            select: {
              id: true,
              title: true,
              group: {
                select: {
                  name: true,
                },
              },
            },
          },
        },
        orderBy: {
          createdAt: "desc",
        },
        take: 10,
      },
    },
  });

  return user;
}

================
File: src/lib/db.js
================
import { PrismaClient } from "@prisma/client";

// Prevent multiple instances of Prisma Client in development
const globalForPrisma = global;

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

export default prisma;

================
File: src/lib/utils.js
================
import { verify } from "jsonwebtoken";
import { format, formatDistanceToNow } from "date-fns";

// JWT authentication utilities
export function getUserFromToken(request) {
  const token = request.cookies.get("auth-token")?.value;

  if (!token) {
    return null;
  }

  try {
    const decoded = verify(
      token,
      process.env.JWT_SECRET || "reddit-clone-secret-key"
    );
    return decoded;
  } catch (error) {
    console.error("Token verification error:", error);
    return null;
  }
}

// Date formatting utilities
export function formatDate(date) {
  return format(new Date(date), "MMM d, yyyy");
}

export function formatRelativeTime(date) {
  return formatDistanceToNow(new Date(date), { addSuffix: true });
}

// Vote calculation utility
export function calculateVoteScore(votes) {
  return votes.reduce((total, vote) => total + vote.value, 0);
}

// Generate random color for group avatar
export function generateGroupColor(name) {
  const colors = [
    "bg-red-500",
    "bg-blue-500",
    "bg-green-500",
    "bg-yellow-500",
    "bg-purple-500",
    "bg-pink-500",
    "bg-indigo-500",
    "bg-orange-500",
    "bg-teal-500",
    "bg-cyan-500",
  ];

  // Use the group name to deterministically select a color
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }

  const index = Math.abs(hash) % colors.length;
  return colors[index];
}

================
File: .gitignore
================
# Node modules
node_modules/

# Next.js build output
.next/

# Static exports
out/

# Dependencies
package-lock.json
yarn.lock
pnpm-lock.yaml

# Local environment variables
.env
.env.local
.env.development.local
.env.production.local
.env.test.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Editor settings
.vscode/
.idea/

# Mac system files
.DS_Store

# Typescript build files
*.tsbuildinfo

# Optional: Ignore Next.js cache
.next/cache/

================
File: docker-compose.yml
================
version: '3'

services:
  reddit-clone:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      # Mount source code for development
      - ./src:/app/src
      - ./public:/app/public
      # Mount database file
      - ./prisma/data:/app/prisma/data
      # Don't overwrite node_modules with potentially incompatible host files
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/data/reddit-clone.db
    command: npm run dev

================
File: Dockerfile
================
FROM node:20-alpine

WORKDIR /app

# Install dependencies first (for better caching)
COPY package.json package-lock.json* ./
RUN npm ci

# Copy project files
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Build the Next.js application
RUN npm run build

# Expose the port
EXPOSE 3000

# Start the application
CMD ["npm", "run", "start"]

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "exclude": ["node_modules"]
}

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true,
  },
  eslint: {
    // Warning: This allows production builds to successfully complete even if
    // your project has ESLint errors.
    ignoreDuringBuilds: true,
  },
};

module.exports = nextConfig;

================
File: package.json
================
{
  "name": "cardinet",
  "version": "1.0.0",
  "main": "next.config.js",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "db:seed": "node prisma/seed.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@prisma/client": "^6.4.1",
    "@tailwindcss/postcss": "^4.0.12",
    "bcryptjs": "^3.0.2",
    "date-fns": "^4.1.0",
    "jsonwebtoken": "^9.0.2",
    "next": "^15.2.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "react-icons": "^5.5.0",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/node": "22.13.10",
    "@types/react": "19.0.10",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.22.0",
    "eslint-config-next": "^15.2.1",
    "postcss": "^8.5.3",
    "prisma": "^6.4.1",
    "tailwindcss": "^4.0.12"
  }
}

================
File: postcss.config.mjs
================
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};
export default config;

================
File: README.md
================
# Reddit Clone

A Reddit-like application built with Next.js, SQLite, and Docker.

## Features

- User authentication (signup, login, logout)
- Group/subreddits
- Post creation and viewing
- Comments and nested replies
- Upvoting/downvoting system
- User profiles
- Simple search functionality

## Tech Stack

- **Frontend**: Next.js with React
- **Backend**: Next.js API routes
- **Database**: SQLite with Prisma ORM
- **Containerization**: Docker
- **Styling**: Tailwind CSS
- **Authentication**: JWT with httpOnly cookies

## Getting Started

### Prerequisites

- [Docker](https://www.docker.com/get-started)
- [Docker Compose](https://docs.docker.com/compose/install/)

### Running the Application

1. Clone the repository:

```bash
git clone https://github.com/yourusername/reddit-clone.git
cd reddit-clone
```

2. Start the application using Docker Compose:

```bash
docker-compose up
```

3. Access the application at [http://localhost:3000](http://localhost:3000)

### Seeding the Database

The application comes with a seed script to populate the database with initial data. To run it:

```bash
docker-compose exec reddit-clone npm run db:seed
```

### Test Users

After running the seed script, you can log in with these test accounts:

- Username: `admin`, Password: `admin123`
- Username: `user1`, Password: `user1pass`
- Username: `user2`, Password: `user2pass`
- Username: `user3`, Password: `user3pass`
- Username: `user4`, Password: `user4pass`
- Username: `user5`, Password: `user5pass`

## Development

### Project Structure

```
reddit-clone/
├── Dockerfile
├── docker-compose.yml
├── package.json
├── next.config.js
├── .env.local
├── prisma/
│   ├── schema.prisma
│   └── seed.js
├── public/
│   └── images/
├── src/
│   ├── app/
│   │   ├── api/
│   │   ├── auth/
│   │   ├── r/[community]/
│   │   ├── user/[username]/
│   │   ├── create/
│   │   ├── search/
│   │   ├── page.js
│   │   └── layout.js
│   ├── components/
│   │   ├── auth/
│   │   ├── community/
│   │   ├── post/
│   │   ├── comment/
│   │   ├── ui/
│   │   └── layout/
│   ├── lib/
│   │   ├── auth.js
│   │   ├── db.js
│   │   └── utils.js
│   └── styles/
└── .gitignore
```

### Making Changes

1. Modify the code as needed
2. The application will automatically update with your changes (hot reloading)
3. For database schema changes, run:

```bash
docker-compose exec reddit-clone npx prisma migrate dev --name your_migration_name
```

## Notes

- This application is designed for local use only
- The default JWT secret should be changed in production
- Data is stored in a SQLite database inside the Docker container at `/app/prisma/data/reddit-clone.db`

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        reddit: {
          orange: "#FF4500",
          red: "#F54404",
          blue: "#0079D3",
          lightgray: "#F6F7F8",
          gray: "#DAE0E6",
          darkgray: "#1A1A1B",
        },
      },
    },
  },
  plugins: [],
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "incremental": true,
    "module": "esnext",
    "esModuleInterop": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
